/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/*!
* jQuery Cycle2; version: 2.1.6 build: 20141007
* http://jquery.malsup.com/cycle2/
* Copyright (c) 2014 M. Alsup; Dual licensed: MIT/GPL
*/

/* Cycle2 core engine */
;(function($) {
"use strict";

var version = '2.1.6';

$.fn.cycle = function( options ) {
    // fix mistakes with the ready state
    var o;
    if ( this.length === 0 && !$.isReady ) {
        o = { s: this.selector, c: this.context };
        $.fn.cycle.log('requeuing slideshow (dom not ready)');
        $(function() {
            $( o.s, o.c ).cycle(options);
        });
        return this;
    }

    return this.each(function() {
        var data, opts, shortName, val;
        var container = $(this);
        var log = $.fn.cycle.log;

        if ( container.data('cycle.opts') )
            return; // already initialized

        if ( container.data('cycle-log') === false || 
            ( options && options.log === false ) ||
            ( opts && opts.log === false) ) {
            log = $.noop;
        }

        log('--c2 init--');
        data = container.data();
        for (var p in data) {
            // allow props to be accessed sans 'cycle' prefix and log the overrides
            if (data.hasOwnProperty(p) && /^cycle[A-Z]+/.test(p) ) {
                val = data[p];
                shortName = p.match(/^cycle(.*)/)[1].replace(/^[A-Z]/, lowerCase);
                log(shortName+':', val, '('+typeof val +')');
                data[shortName] = val;
            }
        }

        opts = $.extend( {}, $.fn.cycle.defaults, data, options || {});

        opts.timeoutId = 0;
        opts.paused = opts.paused || false; // #57
        opts.container = container;
        opts._maxZ = opts.maxZ;

        opts.API = $.extend ( { _container: container }, $.fn.cycle.API );
        opts.API.log = log;
        opts.API.trigger = function( eventName, args ) {
            opts.container.trigger( eventName, args );
            return opts.API;
        };

        container.data( 'cycle.opts', opts );
        container.data( 'cycle.API', opts.API );

        // opportunity for plugins to modify opts and API
        opts.API.trigger('cycle-bootstrap', [ opts, opts.API ]);

        opts.API.addInitialSlides();
        opts.API.preInitSlideshow();

        if ( opts.slides.length )
            opts.API.initSlideshow();
    });
};

$.fn.cycle.API = {
    opts: function() {
        return this._container.data( 'cycle.opts' );
    },
    addInitialSlides: function() {
        var opts = this.opts();
        var slides = opts.slides;
        opts.slideCount = 0;
        opts.slides = $(); // empty set
        
        // add slides that already exist
        slides = slides.jquery ? slides : opts.container.find( slides );

        if ( opts.random ) {
            slides.sort(function() {return Math.random() - 0.5;});
        }

        opts.API.add( slides );
    },

    preInitSlideshow: function() {
        var opts = this.opts();
        opts.API.trigger('cycle-pre-initialize', [ opts ]);
        var tx = $.fn.cycle.transitions[opts.fx];
        if (tx && $.isFunction(tx.preInit))
            tx.preInit( opts );
        opts._preInitialized = true;
    },

    postInitSlideshow: function() {
        var opts = this.opts();
        opts.API.trigger('cycle-post-initialize', [ opts ]);
        var tx = $.fn.cycle.transitions[opts.fx];
        if (tx && $.isFunction(tx.postInit))
            tx.postInit( opts );
    },

    initSlideshow: function() {
        var opts = this.opts();
        var pauseObj = opts.container;
        var slideOpts;
        opts.API.calcFirstSlide();

        if ( opts.container.css('position') == 'static' )
            opts.container.css('position', 'relative');

        $(opts.slides[opts.currSlide]).css({
            opacity: 1,
            display: 'block',
            visibility: 'visible'
        });
        opts.API.stackSlides( opts.slides[opts.currSlide], opts.slides[opts.nextSlide], !opts.reverse );

        if ( opts.pauseOnHover ) {
            // allow pauseOnHover to specify an element
            if ( opts.pauseOnHover !== true )
                pauseObj = $( opts.pauseOnHover );

            pauseObj.hover(
                function(){ opts.API.pause( true ); }, 
                function(){ opts.API.resume( true ); }
            );
        }

        // stage initial transition
        if ( opts.timeout ) {
            slideOpts = opts.API.getSlideOpts( opts.currSlide );
            opts.API.queueTransition( slideOpts, slideOpts.timeout + opts.delay );
        }

        opts._initialized = true;
        opts.API.updateView( true );
        opts.API.trigger('cycle-initialized', [ opts ]);
        opts.API.postInitSlideshow();
    },

    pause: function( hover ) {
        var opts = this.opts(),
            slideOpts = opts.API.getSlideOpts(),
            alreadyPaused = opts.hoverPaused || opts.paused;

        if ( hover )
            opts.hoverPaused = true; 
        else
            opts.paused = true;

        if ( ! alreadyPaused ) {
            opts.container.addClass('cycle-paused');
            opts.API.trigger('cycle-paused', [ opts ]).log('cycle-paused');

            if ( slideOpts.timeout ) {
                clearTimeout( opts.timeoutId );
                opts.timeoutId = 0;
                
                // determine how much time is left for the current slide
                opts._remainingTimeout -= ( $.now() - opts._lastQueue );
                if ( opts._remainingTimeout < 0 || isNaN(opts._remainingTimeout) )
                    opts._remainingTimeout = undefined;
            }
        }
    },

    resume: function( hover ) {
        var opts = this.opts(),
            alreadyResumed = !opts.hoverPaused && !opts.paused,
            remaining;

        if ( hover )
            opts.hoverPaused = false; 
        else
            opts.paused = false;

    
        if ( ! alreadyResumed ) {
            opts.container.removeClass('cycle-paused');
            // #gh-230; if an animation is in progress then don't queue a new transition; it will
            // happen naturally
            if ( opts.slides.filter(':animated').length === 0 )
                opts.API.queueTransition( opts.API.getSlideOpts(), opts._remainingTimeout );
            opts.API.trigger('cycle-resumed', [ opts, opts._remainingTimeout ] ).log('cycle-resumed');
        }
    },

    add: function( slides, prepend ) {
        var opts = this.opts();
        var oldSlideCount = opts.slideCount;
        var startSlideshow = false;
        var len;

        if ( $.type(slides) == 'string')
            slides = $.trim( slides );

        $( slides ).each(function(i) {
            var slideOpts;
            var slide = $(this);

            if ( prepend )
                opts.container.prepend( slide );
            else
                opts.container.append( slide );

            opts.slideCount++;
            slideOpts = opts.API.buildSlideOpts( slide );

            if ( prepend )
                opts.slides = $( slide ).add( opts.slides );
            else
                opts.slides = opts.slides.add( slide );

            opts.API.initSlide( slideOpts, slide, --opts._maxZ );

            slide.data('cycle.opts', slideOpts);
            opts.API.trigger('cycle-slide-added', [ opts, slideOpts, slide ]);
        });

        opts.API.updateView( true );

        startSlideshow = opts._preInitialized && (oldSlideCount < 2 && opts.slideCount >= 1);
        if ( startSlideshow ) {
            if ( !opts._initialized )
                opts.API.initSlideshow();
            else if ( opts.timeout ) {
                len = opts.slides.length;
                opts.nextSlide = opts.reverse ? len - 1 : 1;
                if ( !opts.timeoutId ) {
                    opts.API.queueTransition( opts );
                }
            }
        }
    },

    calcFirstSlide: function() {
        var opts = this.opts();
        var firstSlideIndex;
        firstSlideIndex = parseInt( opts.startingSlide || 0, 10 );
        if (firstSlideIndex >= opts.slides.length || firstSlideIndex < 0)
            firstSlideIndex = 0;

        opts.currSlide = firstSlideIndex;
        if ( opts.reverse ) {
            opts.nextSlide = firstSlideIndex - 1;
            if (opts.nextSlide < 0)
                opts.nextSlide = opts.slides.length - 1;
        }
        else {
            opts.nextSlide = firstSlideIndex + 1;
            if (opts.nextSlide == opts.slides.length)
                opts.nextSlide = 0;
        }
    },

    calcNextSlide: function() {
        var opts = this.opts();
        var roll;
        if ( opts.reverse ) {
            roll = (opts.nextSlide - 1) < 0;
            opts.nextSlide = roll ? opts.slideCount - 1 : opts.nextSlide-1;
            opts.currSlide = roll ? 0 : opts.nextSlide+1;
        }
        else {
            roll = (opts.nextSlide + 1) == opts.slides.length;
            opts.nextSlide = roll ? 0 : opts.nextSlide+1;
            opts.currSlide = roll ? opts.slides.length-1 : opts.nextSlide-1;
        }
    },

    calcTx: function( slideOpts, manual ) {
        var opts = slideOpts;
        var tx;

        if ( opts._tempFx )
            tx = $.fn.cycle.transitions[opts._tempFx];
        else if ( manual && opts.manualFx )
            tx = $.fn.cycle.transitions[opts.manualFx];

        if ( !tx )
            tx = $.fn.cycle.transitions[opts.fx];

        opts._tempFx = null;
        this.opts()._tempFx = null;

        if (!tx) {
            tx = $.fn.cycle.transitions.fade;
            opts.API.log('Transition "' + opts.fx + '" not found.  Using fade.');
        }
        return tx;
    },

    prepareTx: function( manual, fwd ) {
        var opts = this.opts();
        var after, curr, next, slideOpts, tx;

        if ( opts.slideCount < 2 ) {
            opts.timeoutId = 0;
            return;
        }
        if ( manual && ( !opts.busy || opts.manualTrump ) ) {
            opts.API.stopTransition();
            opts.busy = false;
            clearTimeout(opts.timeoutId);
            opts.timeoutId = 0;
        }
        if ( opts.busy )
            return;
        if ( opts.timeoutId === 0 && !manual )
            return;

        curr = opts.slides[opts.currSlide];
        next = opts.slides[opts.nextSlide];
        slideOpts = opts.API.getSlideOpts( opts.nextSlide );
        tx = opts.API.calcTx( slideOpts, manual );

        opts._tx = tx;

        if ( manual && slideOpts.manualSpeed !== undefined )
            slideOpts.speed = slideOpts.manualSpeed;

        // if ( opts.nextSlide === opts.currSlide )
        //     opts.API.calcNextSlide();

        // ensure that:
        //      1. advancing to a different slide
        //      2. this is either a manual event (prev/next, pager, cmd) or 
        //              a timer event and slideshow is not paused
        if ( opts.nextSlide != opts.currSlide && 
            (manual || (!opts.paused && !opts.hoverPaused && opts.timeout) )) { // #62

            opts.API.trigger('cycle-before', [ slideOpts, curr, next, fwd ]);
            if ( tx.before )
                tx.before( slideOpts, curr, next, fwd );

            after = function() {
                opts.busy = false;
                // #76; bail if slideshow has been destroyed
                if (! opts.container.data( 'cycle.opts' ) )
                    return;

                if (tx.after)
                    tx.after( slideOpts, curr, next, fwd );
                opts.API.trigger('cycle-after', [ slideOpts, curr, next, fwd ]);
                opts.API.queueTransition( slideOpts);
                opts.API.updateView( true );
            };

            opts.busy = true;
            if (tx.transition)
                tx.transition(slideOpts, curr, next, fwd, after);
            else
                opts.API.doTransition( slideOpts, curr, next, fwd, after);

            opts.API.calcNextSlide();
            opts.API.updateView();
        } else {
            opts.API.queueTransition( slideOpts );
        }
    },

    // perform the actual animation
    doTransition: function( slideOpts, currEl, nextEl, fwd, callback) {
        var opts = slideOpts;
        var curr = $(currEl), next = $(nextEl);
        var fn = function() {
            // make sure animIn has something so that callback doesn't trigger immediately
            next.animate(opts.animIn || { opacity: 1}, opts.speed, opts.easeIn || opts.easing, callback);
        };

        next.css(opts.cssBefore || {});
        curr.animate(opts.animOut || {}, opts.speed, opts.easeOut || opts.easing, function() {
            curr.css(opts.cssAfter || {});
            if (!opts.sync) {
                fn();
            }
        });
        if (opts.sync) {
            fn();
        }
    },

    queueTransition: function( slideOpts, specificTimeout ) {
        var opts = this.opts();
        var timeout = specificTimeout !== undefined ? specificTimeout : slideOpts.timeout;
        if (opts.nextSlide === 0 && --opts.loop === 0) {
            opts.API.log('terminating; loop=0');
            opts.timeout = 0;
            if ( timeout ) {
                setTimeout(function() {
                    opts.API.trigger('cycle-finished', [ opts ]);
                }, timeout);
            }
            else {
                opts.API.trigger('cycle-finished', [ opts ]);
            }
            // reset nextSlide
            opts.nextSlide = opts.currSlide;
            return;
        }
        if ( opts.continueAuto !== undefined ) {
            if ( opts.continueAuto === false || 
                ($.isFunction(opts.continueAuto) && opts.continueAuto() === false )) {
                opts.API.log('terminating automatic transitions');
                opts.timeout = 0;
                if ( opts.timeoutId )
                    clearTimeout(opts.timeoutId);
                return;
            }
        }
        if ( timeout ) {
            opts._lastQueue = $.now();
            if ( specificTimeout === undefined )
                opts._remainingTimeout = slideOpts.timeout;

            if ( !opts.paused && ! opts.hoverPaused ) {
                opts.timeoutId = setTimeout(function() { 
                    opts.API.prepareTx( false, !opts.reverse ); 
                }, timeout );
            }
        }
    },

    stopTransition: function() {
        var opts = this.opts();
        if ( opts.slides.filter(':animated').length ) {
            opts.slides.stop(false, true);
            opts.API.trigger('cycle-transition-stopped', [ opts ]);
        }

        if ( opts._tx && opts._tx.stopTransition )
            opts._tx.stopTransition( opts );
    },

    // advance slide forward or back
    advanceSlide: function( val ) {
        var opts = this.opts();
        clearTimeout(opts.timeoutId);
        opts.timeoutId = 0;
        opts.nextSlide = opts.currSlide + val;
        
        if (opts.nextSlide < 0)
            opts.nextSlide = opts.slides.length - 1;
        else if (opts.nextSlide >= opts.slides.length)
            opts.nextSlide = 0;

        opts.API.prepareTx( true,  val >= 0 );
        return false;
    },

    buildSlideOpts: function( slide ) {
        var opts = this.opts();
        var val, shortName;
        var slideOpts = slide.data() || {};
        for (var p in slideOpts) {
            // allow props to be accessed sans 'cycle' prefix and log the overrides
            if (slideOpts.hasOwnProperty(p) && /^cycle[A-Z]+/.test(p) ) {
                val = slideOpts[p];
                shortName = p.match(/^cycle(.*)/)[1].replace(/^[A-Z]/, lowerCase);
                opts.API.log('['+(opts.slideCount-1)+']', shortName+':', val, '('+typeof val +')');
                slideOpts[shortName] = val;
            }
        }

        slideOpts = $.extend( {}, $.fn.cycle.defaults, opts, slideOpts );
        slideOpts.slideNum = opts.slideCount;

        try {
            // these props should always be read from the master state object
            delete slideOpts.API;
            delete slideOpts.slideCount;
            delete slideOpts.currSlide;
            delete slideOpts.nextSlide;
            delete slideOpts.slides;
        } catch(e) {
            // no op
        }
        return slideOpts;
    },

    getSlideOpts: function( index ) {
        var opts = this.opts();
        if ( index === undefined )
            index = opts.currSlide;

        var slide = opts.slides[index];
        var slideOpts = $(slide).data('cycle.opts');
        return $.extend( {}, opts, slideOpts );
    },
    
    initSlide: function( slideOpts, slide, suggestedZindex ) {
        var opts = this.opts();
        slide.css( slideOpts.slideCss || {} );
        if ( suggestedZindex > 0 )
            slide.css( 'zIndex', suggestedZindex );

        // ensure that speed settings are sane
        if ( isNaN( slideOpts.speed ) )
            slideOpts.speed = $.fx.speeds[slideOpts.speed] || $.fx.speeds._default;
        if ( !slideOpts.sync )
            slideOpts.speed = slideOpts.speed / 2;

        slide.addClass( opts.slideClass );
    },

    updateView: function( isAfter, isDuring, forceEvent ) {
        var opts = this.opts();
        if ( !opts._initialized )
            return;
        var slideOpts = opts.API.getSlideOpts();
        var currSlide = opts.slides[ opts.currSlide ];

        if ( ! isAfter && isDuring !== true ) {
            opts.API.trigger('cycle-update-view-before', [ opts, slideOpts, currSlide ]);
            if ( opts.updateView < 0 )
                return;
        }

        if ( opts.slideActiveClass ) {
            opts.slides.removeClass( opts.slideActiveClass )
                .eq( opts.currSlide ).addClass( opts.slideActiveClass );
        }

        if ( isAfter && opts.hideNonActive )
            opts.slides.filter( ':not(.' + opts.slideActiveClass + ')' ).css('visibility', 'hidden');

        if ( opts.updateView === 0 ) {
            setTimeout(function() {
                opts.API.trigger('cycle-update-view', [ opts, slideOpts, currSlide, isAfter ]);
            }, slideOpts.speed / (opts.sync ? 2 : 1) );
        }

        if ( opts.updateView !== 0 )
            opts.API.trigger('cycle-update-view', [ opts, slideOpts, currSlide, isAfter ]);
        
        if ( isAfter )
            opts.API.trigger('cycle-update-view-after', [ opts, slideOpts, currSlide ]);
    },

    getComponent: function( name ) {
        var opts = this.opts();
        var selector = opts[name];
        if (typeof selector === 'string') {
            // if selector is a child, sibling combinator, adjancent selector then use find, otherwise query full dom
            return (/^\s*[\>|\+|~]/).test( selector ) ? opts.container.find( selector ) : $( selector );
        }
        if (selector.jquery)
            return selector;
        
        return $(selector);
    },

    stackSlides: function( curr, next, fwd ) {
        var opts = this.opts();
        if ( !curr ) {
            curr = opts.slides[opts.currSlide];
            next = opts.slides[opts.nextSlide];
            fwd = !opts.reverse;
        }

        // reset the zIndex for the common case:
        // curr slide on top,  next slide beneath, and the rest in order to be shown
        $(curr).css('zIndex', opts.maxZ);

        var i;
        var z = opts.maxZ - 2;
        var len = opts.slideCount;
        if (fwd) {
            for ( i = opts.currSlide + 1; i < len; i++ )
                $( opts.slides[i] ).css( 'zIndex', z-- );
            for ( i = 0; i < opts.currSlide; i++ )
                $( opts.slides[i] ).css( 'zIndex', z-- );
        }
        else {
            for ( i = opts.currSlide - 1; i >= 0; i-- )
                $( opts.slides[i] ).css( 'zIndex', z-- );
            for ( i = len - 1; i > opts.currSlide; i-- )
                $( opts.slides[i] ).css( 'zIndex', z-- );
        }

        $(next).css('zIndex', opts.maxZ - 1);
    },

    getSlideIndex: function( el ) {
        return this.opts().slides.index( el );
    }

}; // API

// default logger
$.fn.cycle.log = function log() {
    /*global console:true */
    if (window.console && console.log)
        console.log('[cycle2] ' + Array.prototype.join.call(arguments, ' ') );
};

$.fn.cycle.version = function() { return 'Cycle2: ' + version; };

// helper functions

function lowerCase(s) {
    return (s || '').toLowerCase();
}

// expose transition object
$.fn.cycle.transitions = {
    custom: {
    },
    none: {
        before: function( opts, curr, next, fwd ) {
            opts.API.stackSlides( next, curr, fwd );
            opts.cssBefore = { opacity: 1, visibility: 'visible', display: 'block' };
        }
    },
    fade: {
        before: function( opts, curr, next, fwd ) {
            var css = opts.API.getSlideOpts( opts.nextSlide ).slideCss || {};
            opts.API.stackSlides( curr, next, fwd );
            opts.cssBefore = $.extend(css, { opacity: 0, visibility: 'visible', display: 'block' });
            opts.animIn = { opacity: 1 };
            opts.animOut = { opacity: 0 };
        }
    },
    fadeout: {
        before: function( opts , curr, next, fwd ) {
            var css = opts.API.getSlideOpts( opts.nextSlide ).slideCss || {};
            opts.API.stackSlides( curr, next, fwd );
            opts.cssBefore = $.extend(css, { opacity: 1, visibility: 'visible', display: 'block' });
            opts.animOut = { opacity: 0 };
        }
    },
    scrollHorz: {
        before: function( opts, curr, next, fwd ) {
            opts.API.stackSlides( curr, next, fwd );
            var w = opts.container.css('overflow','hidden').width();
            opts.cssBefore = { left: fwd ? w : - w, top: 0, opacity: 1, visibility: 'visible', display: 'block' };
            opts.cssAfter = { zIndex: opts._maxZ - 2, left: 0 };
            opts.animIn = { left: 0 };
            opts.animOut = { left: fwd ? -w : w };
        }
    }
};

// @see: http://jquery.malsup.com/cycle2/api
$.fn.cycle.defaults = {
    allowWrap:        true,
    autoSelector:     '.cycle-slideshow[data-cycle-auto-init!=false]',
    delay:            0,
    easing:           null,
    fx:              'fade',
    hideNonActive:    true,
    loop:             0,
    manualFx:         undefined,
    manualSpeed:      undefined,
    manualTrump:      true,
    maxZ:             100,
    pauseOnHover:     false,
    reverse:          false,
    slideActiveClass: 'cycle-slide-active',
    slideClass:       'cycle-slide',
    slideCss:         { position: 'absolute', top: 0, left: 0 },
    slides:          '> img',
    speed:            500,
    startingSlide:    0,
    sync:             true,
    timeout:          4000,
    updateView:       0
};

// automatically find and run slideshows
$(document).ready(function() {
    $( $.fn.cycle.defaults.autoSelector ).cycle();
});

})(jQuery);

/*! Cycle2 autoheight plugin; Copyright (c) M.Alsup, 2012; version: 20130913 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    autoHeight: 0, // setting this option to false disables autoHeight logic
    autoHeightSpeed: 250,
    autoHeightEasing: null
});    

$(document).on( 'cycle-initialized', function( e, opts ) {
    var autoHeight = opts.autoHeight;
    var t = $.type( autoHeight );
    var resizeThrottle = null;
    var ratio;

    if ( t !== 'string' && t !== 'number' )
        return;

    // bind events
    opts.container.on( 'cycle-slide-added cycle-slide-removed', initAutoHeight );
    opts.container.on( 'cycle-destroyed', onDestroy );

    if ( autoHeight == 'container' ) {
        opts.container.on( 'cycle-before', onBefore );
    }
    else if ( t === 'string' && /\d+\:\d+/.test( autoHeight ) ) { 
        // use ratio
        ratio = autoHeight.match(/(\d+)\:(\d+)/);
        ratio = ratio[1] / ratio[2];
        opts._autoHeightRatio = ratio;
    }

    // if autoHeight is a number then we don't need to recalculate the sentinel
    // index on resize
    if ( t !== 'number' ) {
        // bind unique resize handler per slideshow (so it can be 'off-ed' in onDestroy)
        opts._autoHeightOnResize = function () {
            clearTimeout( resizeThrottle );
            resizeThrottle = setTimeout( onResize, 50 );
        };

        $(window).on( 'resize orientationchange', opts._autoHeightOnResize );
    }

    setTimeout( onResize, 30 );

    function onResize() {
        initAutoHeight( e, opts );
    }
});

function initAutoHeight( e, opts ) {
    var clone, height, sentinelIndex;
    var autoHeight = opts.autoHeight;

    if ( autoHeight == 'container' ) {
        height = $( opts.slides[ opts.currSlide ] ).outerHeight();
        opts.container.height( height );
    }
    else if ( opts._autoHeightRatio ) { 
        opts.container.height( opts.container.width() / opts._autoHeightRatio );
    }
    else if ( autoHeight === 'calc' || ( $.type( autoHeight ) == 'number' && autoHeight >= 0 ) ) {
        if ( autoHeight === 'calc' )
            sentinelIndex = calcSentinelIndex( e, opts );
        else if ( autoHeight >= opts.slides.length )
            sentinelIndex = 0;
        else 
            sentinelIndex = autoHeight;

        // only recreate sentinel if index is different
        if ( sentinelIndex == opts._sentinelIndex )
            return;

        opts._sentinelIndex = sentinelIndex;
        if ( opts._sentinel )
            opts._sentinel.remove();

        // clone existing slide as sentinel
        clone = $( opts.slides[ sentinelIndex ].cloneNode(true) );
        
        // #50; remove special attributes from cloned content
        clone.removeAttr( 'id name rel' ).find( '[id],[name],[rel]' ).removeAttr( 'id name rel' );

        clone.css({
            position: 'static',
            visibility: 'hidden',
            display: 'block'
        }).prependTo( opts.container ).addClass('cycle-sentinel cycle-slide').removeClass('cycle-slide-active');
        clone.find( '*' ).css( 'visibility', 'hidden' );

        opts._sentinel = clone;
    }
}    

function calcSentinelIndex( e, opts ) {
    var index = 0, max = -1;

    // calculate tallest slide index
    opts.slides.each(function(i) {
        var h = $(this).height();
        if ( h > max ) {
            max = h;
            index = i;
        }
    });
    return index;
}

function onBefore( e, opts, outgoing, incoming, forward ) {
    var h = $(incoming).outerHeight();
    opts.container.animate( { height: h }, opts.autoHeightSpeed, opts.autoHeightEasing );
}

function onDestroy( e, opts ) {
    if ( opts._autoHeightOnResize ) {
        $(window).off( 'resize orientationchange', opts._autoHeightOnResize );
        opts._autoHeightOnResize = null;
    }
    opts.container.off( 'cycle-slide-added cycle-slide-removed', initAutoHeight );
    opts.container.off( 'cycle-destroyed', onDestroy );
    opts.container.off( 'cycle-before', onBefore );

    if ( opts._sentinel ) {
        opts._sentinel.remove();
        opts._sentinel = null;
    }
}

})(jQuery);

/*! caption plugin for Cycle2;  version: 20130306 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    caption:          '> .cycle-caption',
    captionTemplate:  '{{slideNum}} / {{slideCount}}',
    overlay:          '> .cycle-overlay',
    overlayTemplate:  '<div>{{title}}</div><div>{{desc}}</div>',
    captionModule:    'caption'
});    

$(document).on( 'cycle-update-view', function( e, opts, slideOpts, currSlide ) {
    if ( opts.captionModule !== 'caption' )
        return;
    var el;
    $.each(['caption','overlay'], function() {
        var name = this; 
        var template = slideOpts[name+'Template'];
        var el = opts.API.getComponent( name );
        if( el.length && template ) {
            el.html( opts.API.tmpl( template, slideOpts, opts, currSlide ) );
            el.show();
        }
        else {
            el.hide();
        }
    });
});

$(document).on( 'cycle-destroyed', function( e, opts ) {
    var el;
    $.each(['caption','overlay'], function() {
        var name = this, template = opts[name+'Template'];
        if ( opts[name] && template ) {
            el = opts.API.getComponent( 'caption' );
            el.empty();
        }
    });
});

})(jQuery);

/*! command plugin for Cycle2;  version: 20140415 */
(function($) {
"use strict";

var c2 = $.fn.cycle;

$.fn.cycle = function( options ) {
    var cmd, cmdFn, opts;
    var args = $.makeArray( arguments );

    if ( $.type( options ) == 'number' ) {
        return this.cycle( 'goto', options );
    }

    if ( $.type( options ) == 'string' ) {
        return this.each(function() {
            var cmdArgs;
            cmd = options;
            opts = $(this).data('cycle.opts');

            if ( opts === undefined ) {
                c2.log('slideshow must be initialized before sending commands; "' + cmd + '" ignored');
                return;
            }
            else {
                cmd = cmd == 'goto' ? 'jump' : cmd; // issue #3; change 'goto' to 'jump' internally
                cmdFn = opts.API[ cmd ];
                if ( $.isFunction( cmdFn )) {
                    cmdArgs = $.makeArray( args );
                    cmdArgs.shift();
                    return cmdFn.apply( opts.API, cmdArgs );
                }
                else {
                    c2.log( 'unknown command: ', cmd );
                }
            }
        });
    }
    else {
        return c2.apply( this, arguments );
    }
};

// copy props
$.extend( $.fn.cycle, c2 );

$.extend( c2.API, {
    next: function() {
        var opts = this.opts();
        if ( opts.busy && ! opts.manualTrump )
            return;

        var count = opts.reverse ? -1 : 1;
        if ( opts.allowWrap === false && ( opts.currSlide + count ) >= opts.slideCount )
            return;

        opts.API.advanceSlide( count );
        opts.API.trigger('cycle-next', [ opts ]).log('cycle-next');
    },

    prev: function() {
        var opts = this.opts();
        if ( opts.busy && ! opts.manualTrump )
            return;
        var count = opts.reverse ? 1 : -1;
        if ( opts.allowWrap === false && ( opts.currSlide + count ) < 0 )
            return;

        opts.API.advanceSlide( count );
        opts.API.trigger('cycle-prev', [ opts ]).log('cycle-prev');
    },

    destroy: function() {
        this.stop(); //#204

        var opts = this.opts();
        var clean = $.isFunction( $._data ) ? $._data : $.noop;  // hack for #184 and #201
        clearTimeout(opts.timeoutId);
        opts.timeoutId = 0;
        opts.API.stop();
        opts.API.trigger( 'cycle-destroyed', [ opts ] ).log('cycle-destroyed');
        opts.container.removeData();
        clean( opts.container[0], 'parsedAttrs', false );

        // #75; remove inline styles
        if ( ! opts.retainStylesOnDestroy ) {
            opts.container.removeAttr( 'style' );
            opts.slides.removeAttr( 'style' );
            opts.slides.removeClass( opts.slideActiveClass );
        }
        opts.slides.each(function() {
            var slide = $(this);
            slide.removeData();
            slide.removeClass( opts.slideClass );
            clean( this, 'parsedAttrs', false );
        });
    },

    jump: function( index, fx ) {
        // go to the requested slide
        var fwd;
        var opts = this.opts();
        if ( opts.busy && ! opts.manualTrump )
            return;
        var num = parseInt( index, 10 );
        if (isNaN(num) || num < 0 || num >= opts.slides.length) {
            opts.API.log('goto: invalid slide index: ' + num);
            return;
        }
        if (num == opts.currSlide) {
            opts.API.log('goto: skipping, already on slide', num);
            return;
        }
        opts.nextSlide = num;
        clearTimeout(opts.timeoutId);
        opts.timeoutId = 0;
        opts.API.log('goto: ', num, ' (zero-index)');
        fwd = opts.currSlide < opts.nextSlide;
        opts._tempFx = fx;
        opts.API.prepareTx( true, fwd );
    },

    stop: function() {
        var opts = this.opts();
        var pauseObj = opts.container;
        clearTimeout(opts.timeoutId);
        opts.timeoutId = 0;
        opts.API.stopTransition();
        if ( opts.pauseOnHover ) {
            if ( opts.pauseOnHover !== true )
                pauseObj = $( opts.pauseOnHover );
            pauseObj.off('mouseenter mouseleave');
        }
        opts.API.trigger('cycle-stopped', [ opts ]).log('cycle-stopped');
    },

    reinit: function() {
        var opts = this.opts();
        opts.API.destroy();
        opts.container.cycle();
    },

    remove: function( index ) {
        var opts = this.opts();
        var slide, slideToRemove, slides = [], slideNum = 1;
        for ( var i=0; i < opts.slides.length; i++ ) {
            slide = opts.slides[i];
            if ( i == index ) {
                slideToRemove = slide;
            }
            else {
                slides.push( slide );
                $( slide ).data('cycle.opts').slideNum = slideNum;
                slideNum++;
            }
        }
        if ( slideToRemove ) {
            opts.slides = $( slides );
            opts.slideCount--;
            $( slideToRemove ).remove();
            if (index == opts.currSlide)
                opts.API.advanceSlide( 1 );
            else if ( index < opts.currSlide )
                opts.currSlide--;
            else
                opts.currSlide++;

            opts.API.trigger('cycle-slide-removed', [ opts, index, slideToRemove ]).log('cycle-slide-removed');
            opts.API.updateView();
        }
    }

});

// listen for clicks on elements with data-cycle-cmd attribute
$(document).on('click.cycle', '[data-cycle-cmd]', function(e) {
    // issue cycle command
    e.preventDefault();
    var el = $(this);
    var command = el.data('cycle-cmd');
    var context = el.data('cycle-context') || '.cycle-slideshow';
    $(context).cycle(command, el.data('cycle-arg'));
});


})(jQuery);

/*! hash plugin for Cycle2;  version: 20130905 */
(function($) {
"use strict";

$(document).on( 'cycle-pre-initialize', function( e, opts ) {
    onHashChange( opts, true );

    opts._onHashChange = function() {
        onHashChange( opts, false );
    };

    $( window ).on( 'hashchange', opts._onHashChange);
});

$(document).on( 'cycle-update-view', function( e, opts, slideOpts ) {
    if ( slideOpts.hash && ( '#' + slideOpts.hash ) != window.location.hash ) {
        opts._hashFence = true;
        window.location.hash = slideOpts.hash;
    }
});

$(document).on( 'cycle-destroyed', function( e, opts) {
    if ( opts._onHashChange ) {
        $( window ).off( 'hashchange', opts._onHashChange );
    }
});

function onHashChange( opts, setStartingSlide ) {
    var hash;
    if ( opts._hashFence ) {
        opts._hashFence = false;
        return;
    }
    
    hash = window.location.hash.substring(1);

    opts.slides.each(function(i) {
        if ( $(this).data( 'cycle-hash' ) == hash ) {
            if ( setStartingSlide === true ) {
                opts.startingSlide = i;
            }
            else {
                var fwd = opts.currSlide < i;
                opts.nextSlide = i;
                opts.API.prepareTx( true, fwd );
            }
            return false;
        }
    });
}

})(jQuery);

/*! loader plugin for Cycle2;  version: 20131121 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    loader: false
});

$(document).on( 'cycle-bootstrap', function( e, opts ) {
    var addFn;

    if ( !opts.loader )
        return;

    // override API.add for this slideshow
    addFn = opts.API.add;
    opts.API.add = add;

    function add( slides, prepend ) {
        var slideArr = [];
        if ( $.type( slides ) == 'string' )
            slides = $.trim( slides );
        else if ( $.type( slides) === 'array' ) {
            for (var i=0; i < slides.length; i++ )
                slides[i] = $(slides[i])[0];
        }

        slides = $( slides );
        var slideCount = slides.length;

        if ( ! slideCount )
            return;

        slides.css('visibility','hidden').appendTo('body').each(function(i) { // appendTo fixes #56
            var count = 0;
            var slide = $(this);
            var images = slide.is('img') ? slide : slide.find('img');
            slide.data('index', i);
            // allow some images to be marked as unimportant (and filter out images w/o src value)
            images = images.filter(':not(.cycle-loader-ignore)').filter(':not([src=""])');
            if ( ! images.length ) {
                --slideCount;
                slideArr.push( slide );
                return;
            }

            count = images.length;
            images.each(function() {
                // add images that are already loaded
                if ( this.complete ) {
                    imageLoaded();
                }
                else {
                    $(this).load(function() {
                        imageLoaded();
                    }).on("error", function() {
                        if ( --count === 0 ) {
                            // ignore this slide
                            opts.API.log('slide skipped; img not loaded:', this.src);
                            if ( --slideCount === 0 && opts.loader == 'wait') {
                                addFn.apply( opts.API, [ slideArr, prepend ] );
                            }
                        }
                    });
                }
            });

            function imageLoaded() {
                if ( --count === 0 ) {
                    --slideCount;
                    addSlide( slide );
                }
            }
        });

        if ( slideCount )
            opts.container.addClass('cycle-loading');
        

        function addSlide( slide ) {
            var curr;
            if ( opts.loader == 'wait' ) {
                slideArr.push( slide );
                if ( slideCount === 0 ) {
                    // #59; sort slides into original markup order
                    slideArr.sort( sorter );
                    addFn.apply( opts.API, [ slideArr, prepend ] );
                    opts.container.removeClass('cycle-loading');
                }
            }
            else {
                curr = $(opts.slides[opts.currSlide]);
                addFn.apply( opts.API, [ slide, prepend ] );
                curr.show();
                opts.container.removeClass('cycle-loading');
            }
        }

        function sorter(a, b) {
            return a.data('index') - b.data('index');
        }
    }
});

})(jQuery);

/*! pager plugin for Cycle2;  version: 20140415 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    pager:            '> .cycle-pager',
    pagerActiveClass: 'cycle-pager-active',
    pagerEvent:       'click.cycle',
    pagerEventBubble: undefined,
    pagerTemplate:    '<span>&bull;</span>'
});

$(document).on( 'cycle-bootstrap', function( e, opts, API ) {
    // add method to API
    API.buildPagerLink = buildPagerLink;
});

$(document).on( 'cycle-slide-added', function( e, opts, slideOpts, slideAdded ) {
    if ( opts.pager ) {
        opts.API.buildPagerLink ( opts, slideOpts, slideAdded );
        opts.API.page = page;
    }
});

$(document).on( 'cycle-slide-removed', function( e, opts, index, slideRemoved ) {
    if ( opts.pager ) {
        var pagers = opts.API.getComponent( 'pager' );
        pagers.each(function() {
            var pager = $(this);
            $( pager.children()[index] ).remove();
        });
    }
});

$(document).on( 'cycle-update-view', function( e, opts, slideOpts ) {
    var pagers;

    if ( opts.pager ) {
        pagers = opts.API.getComponent( 'pager' );
        pagers.each(function() {
           $(this).children().removeClass( opts.pagerActiveClass )
            .eq( opts.currSlide ).addClass( opts.pagerActiveClass );
        });
    }
});

$(document).on( 'cycle-destroyed', function( e, opts ) {
    var pager = opts.API.getComponent( 'pager' );

    if ( pager ) {
        pager.children().off( opts.pagerEvent ); // #202
        if ( opts.pagerTemplate )
            pager.empty();
    }
});

function buildPagerLink( opts, slideOpts, slide ) {
    var pagerLink;
    var pagers = opts.API.getComponent( 'pager' );
    pagers.each(function() {
        var pager = $(this);
        if ( slideOpts.pagerTemplate ) {
            var markup = opts.API.tmpl( slideOpts.pagerTemplate, slideOpts, opts, slide[0] );
            pagerLink = $( markup ).appendTo( pager );
        }
        else {
            pagerLink = pager.children().eq( opts.slideCount - 1 );
        }
        pagerLink.on( opts.pagerEvent, function(e) {
            if ( ! opts.pagerEventBubble )
                e.preventDefault();
            opts.API.page( pager, e.currentTarget);
        });
    });
}

function page( pager, target ) {
    /*jshint validthis:true */
    var opts = this.opts();
    if ( opts.busy && ! opts.manualTrump )
        return;

    var index = pager.children().index( target );
    var nextSlide = index;
    var fwd = opts.currSlide < nextSlide;
    if (opts.currSlide == nextSlide) {
        return; // no op, clicked pager for the currently displayed slide
    }
    opts.nextSlide = nextSlide;
    opts._tempFx = opts.pagerFx;
    opts.API.prepareTx( true, fwd );
    opts.API.trigger('cycle-pager-activated', [opts, pager, target ]);
}

})(jQuery);

/*! prevnext plugin for Cycle2;  version: 20140408 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    next:           '> .cycle-next',
    nextEvent:      'click.cycle',
    disabledClass:  'disabled',
    prev:           '> .cycle-prev',
    prevEvent:      'click.cycle',
    swipe:          false
});

$(document).on( 'cycle-initialized', function( e, opts ) {
    opts.API.getComponent( 'next' ).on( opts.nextEvent, function(e) {
        e.preventDefault();
        opts.API.next();
    });

    opts.API.getComponent( 'prev' ).on( opts.prevEvent, function(e) {
        e.preventDefault();
        opts.API.prev();
    });

    if ( opts.swipe ) {
        var nextEvent = opts.swipeVert ? 'swipeUp.cycle' : 'swipeLeft.cycle swipeleft.cycle';
        var prevEvent = opts.swipeVert ? 'swipeDown.cycle' : 'swipeRight.cycle swiperight.cycle';
        opts.container.on( nextEvent, function(e) {
            opts._tempFx = opts.swipeFx;
            opts.API.next();
        });
        opts.container.on( prevEvent, function() {
            opts._tempFx = opts.swipeFx;
            opts.API.prev();
        });
    }
});

$(document).on( 'cycle-update-view', function( e, opts, slideOpts, currSlide ) {
    if ( opts.allowWrap )
        return;

    var cls = opts.disabledClass;
    var next = opts.API.getComponent( 'next' );
    var prev = opts.API.getComponent( 'prev' );
    var prevBoundry = opts._prevBoundry || 0;
    var nextBoundry = (opts._nextBoundry !== undefined)?opts._nextBoundry:opts.slideCount - 1;

    if ( opts.currSlide == nextBoundry )
        next.addClass( cls ).prop( 'disabled', true );
    else
        next.removeClass( cls ).prop( 'disabled', false );

    if ( opts.currSlide === prevBoundry )
        prev.addClass( cls ).prop( 'disabled', true );
    else
        prev.removeClass( cls ).prop( 'disabled', false );
});


$(document).on( 'cycle-destroyed', function( e, opts ) {
    opts.API.getComponent( 'prev' ).off( opts.nextEvent );
    opts.API.getComponent( 'next' ).off( opts.prevEvent );
    opts.container.off( 'swipeleft.cycle swiperight.cycle swipeLeft.cycle swipeRight.cycle swipeUp.cycle swipeDown.cycle' );
});

})(jQuery);

/*! progressive loader plugin for Cycle2;  version: 20130315 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    progressive: false
});

$(document).on( 'cycle-pre-initialize', function( e, opts ) {
    if ( !opts.progressive )
        return;

    var API = opts.API;
    var nextFn = API.next;
    var prevFn = API.prev;
    var prepareTxFn = API.prepareTx;
    var type = $.type( opts.progressive );
    var slides, scriptEl;

    if ( type == 'array' ) {
        slides = opts.progressive;
    }
    else if ($.isFunction( opts.progressive ) ) {
        slides = opts.progressive( opts );
    }
    else if ( type == 'string' ) {
        scriptEl = $( opts.progressive );
        slides = $.trim( scriptEl.html() );
        if ( !slides )
            return;
        // is it json array?
        if ( /^(\[)/.test( slides ) ) {
            try {
                slides = $.parseJSON( slides );
            }
            catch(err) {
                API.log( 'error parsing progressive slides', err );
                return;
            }
        }
        else {
            // plain text, split on delimeter
            slides = slides.split( new RegExp( scriptEl.data('cycle-split') || '\n') );
            
            // #95; look for empty slide
            if ( ! slides[ slides.length - 1 ] )
                slides.pop();
        }
    }



    if ( prepareTxFn ) {
        API.prepareTx = function( manual, fwd ) {
            var index, slide;

            if ( manual || slides.length === 0 ) {
                prepareTxFn.apply( opts.API, [ manual, fwd ] );
                return;
            }

            if ( fwd && opts.currSlide == ( opts.slideCount-1) ) {
                slide = slides[ 0 ];
                slides = slides.slice( 1 );
                opts.container.one('cycle-slide-added', function(e, opts ) {
                    setTimeout(function() {
                        opts.API.advanceSlide( 1 );
                    },50);
                });
                opts.API.add( slide );
            }
            else if ( !fwd && opts.currSlide === 0 ) {
                index = slides.length-1;
                slide = slides[ index ];
                slides = slides.slice( 0, index );
                opts.container.one('cycle-slide-added', function(e, opts ) {
                    setTimeout(function() {
                        opts.currSlide = 1;
                        opts.API.advanceSlide( -1 );
                    },50);
                });
                opts.API.add( slide, true );
            }
            else {
                prepareTxFn.apply( opts.API, [ manual, fwd ] );
            }
        };
    }

    if ( nextFn ) {
        API.next = function() {
            var opts = this.opts();
            if ( slides.length && opts.currSlide == ( opts.slideCount - 1 ) ) {
                var slide = slides[ 0 ];
                slides = slides.slice( 1 );
                opts.container.one('cycle-slide-added', function(e, opts ) {
                    nextFn.apply( opts.API );
                    opts.container.removeClass('cycle-loading');
                });
                opts.container.addClass('cycle-loading');
                opts.API.add( slide );
            }
            else {
                nextFn.apply( opts.API );    
            }
        };
    }
    
    if ( prevFn ) {
        API.prev = function() {
            var opts = this.opts();
            if ( slides.length && opts.currSlide === 0 ) {
                var index = slides.length-1;
                var slide = slides[ index ];
                slides = slides.slice( 0, index );
                opts.container.one('cycle-slide-added', function(e, opts ) {
                    opts.currSlide = 1;
                    opts.API.advanceSlide( -1 );
                    opts.container.removeClass('cycle-loading');
                });
                opts.container.addClass('cycle-loading');
                opts.API.add( slide, true );
            }
            else {
                prevFn.apply( opts.API );
            }
        };
    }
});

})(jQuery);

/*! tmpl plugin for Cycle2;  version: 20121227 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    tmplRegex: '{{((.)?.*?)}}'
});

$.extend($.fn.cycle.API, {
    tmpl: function( str, opts /*, ... */) {
        var regex = new RegExp( opts.tmplRegex || $.fn.cycle.defaults.tmplRegex, 'g' );
        var args = $.makeArray( arguments );
        args.shift();
        return str.replace(regex, function(_, str) {
            var i, j, obj, prop, names = str.split('.');
            for (i=0; i < args.length; i++) {
                obj = args[i];
                if ( ! obj )
                    continue;
                if (names.length > 1) {
                    prop = obj;
                    for (j=0; j < names.length; j++) {
                        obj = prop;
                        prop = prop[ names[j] ] || str;
                    }
                } else {
                    prop = obj[str];
                }

                if ($.isFunction(prop))
                    return prop.apply(obj, args);
                if (prop !== undefined && prop !== null && prop != str)
                    return prop;
            }
            return str;
        });
    }
});    

})(jQuery);

/*! swipe plugin for Cycle2;  version: 20121120 */
(function($) {
"use strict";

// this script adds support for touch events.  the logic is lifted from jQuery Mobile.
// if you have jQuery Mobile installed, you do NOT need this script

var supportTouch = 'ontouchend' in document;

$.event.special.swipe = $.event.special.swipe || {
    scrollSupressionThreshold: 10,   // More than this horizontal displacement, and we will suppress scrolling.
    durationThreshold: 1000,         // More time than this, and it isn't a swipe.
    horizontalDistanceThreshold: 30, // Swipe horizontal displacement must be more than this.
    verticalDistanceThreshold: 75,   // Swipe vertical displacement must be less than this.

    setup: function() {
        var $this = $( this );

        $this.bind( 'touchstart', function( event ) {
            var data = event.originalEvent.touches ? event.originalEvent.touches[ 0 ] : event;
            var stop, start = {
                time: ( new Date() ).getTime(),
                coords: [ data.pageX, data.pageY ],
                origin: $( event.target )
            };

            function moveHandler( event ) {
                if ( !start )
                    return;

                var data = event.originalEvent.touches ? event.originalEvent.touches[ 0 ] : event;

                stop = {
                    time: ( new Date() ).getTime(),
                    coords: [ data.pageX, data.pageY ]
                };

                // prevent scrolling
                if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
                    event.preventDefault();
                }
            }

            $this.bind( 'touchmove', moveHandler )
                .one( 'touchend', function( event ) {
                    $this.unbind( 'touchmove', moveHandler );

                    if ( start && stop ) {
                        if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
                                Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
                                Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {

                            start.origin.trigger( "swipe" )
                                .trigger( start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight" );
                        }
                    }
                    start = stop = undefined;
                });
        });
    }
};

$.event.special.swipeleft = $.event.special.swipeleft || {
    setup: function() {
        $( this ).bind( 'swipe', $.noop );
    }
};
$.event.special.swiperight = $.event.special.swiperight || $.event.special.swipeleft;

})(jQuery);

/*! css3 flip transition plugin for Cycle2;  version: 20140128 */
/*! originally written by Laubeee (https://github.com/Laubeee) */
(function($) {
"use strict";

var backface,
    style = document.createElement('div').style,
    tx = $.fn.cycle.transitions,
    supported = style.transform !== undefined ||
        style.MozTransform !== undefined ||
        style.webkitTransform !== undefined ||
        style.oTransform !== undefined ||
        style.msTransform !== undefined;

if ( supported && style.msTransform !== undefined ) {
    style.msTransform = 'rotateY(0deg)';
    if ( ! style.msTransform )
        supported = false;
}

if ( supported ) {
    tx.flipHorz = getTransition( getRotate('Y') );
    tx.flipVert = getTransition( getRotate('X') );
    backface = {
        '-webkit-backface-visibility': 'hidden',
        '-moz-backface-visibility': 'hidden',
        '-o-backface-visibility': 'hidden',
        'backface-visibility': 'hidden'
    };
}
else {
    // fallback to scroll tx for browsers that don't support transforms
    tx.flipHorz = tx.scrollHorz;
    tx.flipVert = tx.scrollVert || tx.scrollHorz;
}

    
function getTransition( rotateFn ) {
    // return C2 transition object
    return {
        preInit: function( opts ) {
            opts.slides.css( backface );
        },
        transition: function( slideOpts, currEl, nextEl, fwd, callback ) {
            var opts = slideOpts,
                curr = $(currEl), 
                next = $(nextEl),
                speed = opts.speed / 2;

            // css before transition start
            rotateFn.call(next, -90);
            next.css({
                'display': 'block',
                'visibility': 'visible',
                'background-position': '-90px',
                'opacity': 1
            });

            curr.css('background-position', '0px');

            curr.animate({ backgroundPosition: 90 }, {
                step: rotateFn,
                duration: speed,
                easing: opts.easeOut || opts.easing,
                complete: function() {
                    slideOpts.API.updateView( false, true );
                    next.animate({ backgroundPosition: 0 }, {
                        step: rotateFn,
                        duration: speed,
                        easing: opts.easeIn || opts.easing,
                        complete: callback
                    });
                }
            });
        }
    };
}

function getRotate( dir ) {
    return function( degrees ) {
        /*jshint validthis:true */
        var el = $(this);
        el.css({
            '-webkit-transform': 'rotate'+dir+'('+degrees+'deg)',
            '-moz-transform': 'rotate'+dir+'('+degrees+'deg)', 
            '-ms-transform': 'rotate'+dir+'('+degrees+'deg)',
            '-o-transform': 'rotate'+dir+'('+degrees+'deg)',
            'transform': 'rotate'+dir+'('+degrees+'deg)'
        });
    };
}

})(jQuery);

/*! carousel transition plugin for Cycle2;  version: 20130528 */
(function($) {
"use strict";

$( document ).on('cycle-bootstrap', function( e, opts, API ) {
    if ( opts.fx !== 'carousel' )
        return;

    API.getSlideIndex = function( el ) {
        var slides = this.opts()._carouselWrap.children();
        var i = slides.index( el );
        return i % slides.length;
    };

    // override default 'next' function
    API.next = function() {
        var count = opts.reverse ? -1 : 1;
        if ( opts.allowWrap === false && ( opts.currSlide + count ) > opts.slideCount - opts.carouselVisible )
            return;
        opts.API.advanceSlide( count );
        opts.API.trigger('cycle-next', [ opts ]).log('cycle-next');
    };

});


$.fn.cycle.transitions.carousel = {
    // transition API impl
    preInit: function( opts ) {
        opts.hideNonActive = false;
        
        opts.container.on('cycle-destroyed', $.proxy(this.onDestroy, opts.API));
        // override default API implementation
        opts.API.stopTransition = this.stopTransition;

        // issue #10
        for (var i=0; i < opts.startingSlide; i++) {
            opts.container.append( opts.slides[0] );
        }        
    },

    // transition API impl
    postInit: function( opts ) {
        var i, j, slide, pagerCutoffIndex, wrap;
        var vert = opts.carouselVertical;
        if (opts.carouselVisible && opts.carouselVisible > opts.slideCount)
            opts.carouselVisible = opts.slideCount - 1;
        var visCount = opts.carouselVisible || opts.slides.length;
        var slideCSS = { display: vert ? 'block' : 'inline-block', position: 'static' };

        // required styles
        opts.container.css({ position: 'relative', overflow: 'hidden' });
        opts.slides.css( slideCSS );

        opts._currSlide = opts.currSlide;

        // wrap slides in a div; this div is what is animated
        wrap = $('<div class="cycle-carousel-wrap"></div>')
            .prependTo( opts.container )
            .css({ margin: 0, padding: 0, top: 0, left: 0, position: 'absolute' })
            .append( opts.slides );

        opts._carouselWrap = wrap;

        if ( !vert )
            wrap.css('white-space', 'nowrap');

        if ( opts.allowWrap !== false ) {
            // prepend and append extra slides so we don't see any empty space when we
            // near the end of the carousel.  for fluid containers, add even more clones
            // so there is plenty to fill the screen
            // @todo: optimzie this based on slide sizes

            for ( j=0; j < (opts.carouselVisible === undefined ? 2 : 1); j++ ) {
                for ( i=0; i < opts.slideCount; i++ ) {
                    wrap.append( opts.slides[i].cloneNode(true) );
                }
                i = opts.slideCount;
                while ( i-- ) { // #160, #209
                    wrap.prepend( opts.slides[i].cloneNode(true) );
                }
            }

            wrap.find('.cycle-slide-active').removeClass('cycle-slide-active');
            opts.slides.eq(opts.startingSlide).addClass('cycle-slide-active');
        }

        if ( opts.pager && opts.allowWrap === false ) {
            // hide "extra" pagers
            pagerCutoffIndex = opts.slideCount - visCount;
            $( opts.pager ).children().filter( ':gt('+pagerCutoffIndex+')' ).hide();
        }

        opts._nextBoundry = opts.slideCount - opts.carouselVisible;

        this.prepareDimensions( opts );
    },

    prepareDimensions: function( opts ) {
        var dim, offset, pagerCutoffIndex, tmp, j;
        var vert = opts.carouselVertical;
        var visCount = opts.carouselVisible || opts.slides.length;

        if ( opts.carouselFluid && opts.carouselVisible ) {
            if ( ! opts._carouselResizeThrottle ) {
            // fluid container AND fluid slides; slides need to be resized to fit container
                this.fluidSlides( opts );
            }
        }
        else if ( opts.carouselVisible && opts.carouselSlideDimension ) {
            dim = visCount * opts.carouselSlideDimension;
            opts.container[ vert ? 'height' : 'width' ]( dim );
        }
        else if ( opts.carouselVisible ) {
            dim = visCount * $(opts.slides[0])[vert ? 'outerHeight' : 'outerWidth'](true);
            opts.container[ vert ? 'height' : 'width' ]( dim );
        }
        // else {
        //     // fluid; don't size the container
        // }

        offset = ( opts.carouselOffset || 0 );
        if ( opts.allowWrap !== false ) {
            if ( opts.carouselSlideDimension ) {
                offset -= ( (opts.slideCount + opts.currSlide) * opts.carouselSlideDimension );
            }
            else {
                // calculate offset based on actual slide dimensions
                tmp = opts._carouselWrap.children();
                for (j=0; j < (opts.slideCount + opts.currSlide); j++) {
                    offset -= $(tmp[j])[vert?'outerHeight':'outerWidth'](true);
                }
            }
        }

        opts._carouselWrap.css( vert ? 'top' : 'left', offset );
    },

    fluidSlides: function( opts ) {
        var timeout;
        var slide = opts.slides.eq(0);
        var adjustment = slide.outerWidth() - slide.width();
        var prepareDimensions = this.prepareDimensions;

        // throttle resize event
        $(window).on( 'resize', resizeThrottle);

        opts._carouselResizeThrottle = resizeThrottle;
        onResize();

        function resizeThrottle() {
            clearTimeout( timeout );
            timeout = setTimeout( onResize, 20 );
        }

        function onResize() {
            opts._carouselWrap.stop( false, true );
            var slideWidth = opts.container.width() / opts.carouselVisible;
            slideWidth = Math.ceil( slideWidth - adjustment );
            opts._carouselWrap.children().width( slideWidth );
            if ( opts._sentinel )
                opts._sentinel.width( slideWidth );
            prepareDimensions( opts );
        }
    },

    // transition API impl
    transition: function( opts, curr, next, fwd, callback ) {
        var moveBy, props = {};
        var hops = opts.nextSlide - opts.currSlide;
        var vert = opts.carouselVertical;
        var speed = opts.speed;

        // handle all the edge cases for wrapping & non-wrapping
        if ( opts.allowWrap === false ) {
            fwd = hops > 0;
            var currSlide = opts._currSlide;
            var maxCurr = opts.slideCount - opts.carouselVisible;
            if ( hops > 0 && opts.nextSlide > maxCurr && currSlide == maxCurr ) {
                hops = 0;
            }
            else if ( hops > 0 && opts.nextSlide > maxCurr ) {
                hops = opts.nextSlide - currSlide - (opts.nextSlide - maxCurr);
            }
            else if ( hops < 0 && opts.currSlide > maxCurr && opts.nextSlide > maxCurr ) {
                hops = 0;
            }
            else if ( hops < 0 && opts.currSlide > maxCurr ) {
                hops += opts.currSlide - maxCurr;
            }
            else 
                currSlide = opts.currSlide;

            moveBy = this.getScroll( opts, vert, currSlide, hops );
            opts.API.opts()._currSlide = opts.nextSlide > maxCurr ? maxCurr : opts.nextSlide;
        }
        else {
            if ( fwd && opts.nextSlide === 0 ) {
                // moving from last slide to first
                moveBy = this.getDim( opts, opts.currSlide, vert );
                callback = this.genCallback( opts, fwd, vert, callback );
            }
            else if ( !fwd && opts.nextSlide == opts.slideCount - 1 ) {
                // moving from first slide to last
                moveBy = this.getDim( opts, opts.currSlide, vert );
                callback = this.genCallback( opts, fwd, vert, callback );
            }
            else {
                moveBy = this.getScroll( opts, vert, opts.currSlide, hops );
            }
        }

        props[ vert ? 'top' : 'left' ] = fwd ? ( "-=" + moveBy ) : ( "+=" + moveBy );

        // throttleSpeed means to scroll slides at a constant rate, rather than
        // a constant speed
        if ( opts.throttleSpeed )
            speed = (moveBy / $(opts.slides[0])[vert ? 'height' : 'width']() ) * opts.speed;

        opts._carouselWrap.animate( props, speed, opts.easing, callback );
    },

    getDim: function( opts, index, vert ) {
        var slide = $( opts.slides[index] );
        return slide[ vert ? 'outerHeight' : 'outerWidth'](true);
    },

    getScroll: function( opts, vert, currSlide, hops ) {
        var i, moveBy = 0;

        if (hops > 0) {
            for (i=currSlide; i < currSlide+hops; i++)
                moveBy += this.getDim( opts, i, vert);
        }
        else {
            for (i=currSlide; i > currSlide+hops; i--)
                moveBy += this.getDim( opts, i, vert);
        }
        return moveBy;
    },

    genCallback: function( opts, fwd, vert, callback ) {
        // returns callback fn that resets the left/top wrap position to the "real" slides
        return function() {
            var pos = $(opts.slides[opts.nextSlide]).position();
            var offset = 0 - pos[vert?'top':'left'] + (opts.carouselOffset || 0);
            opts._carouselWrap.css( opts.carouselVertical ? 'top' : 'left', offset );
            callback();
        };
    },

    // core API override
    stopTransition: function() {
        var opts = this.opts();
        opts.slides.stop( false, true );
        opts._carouselWrap.stop( false, true );
    },

    // core API supplement
    onDestroy: function( e ) {
        var opts = this.opts();
        if ( opts._carouselResizeThrottle )
            $( window ).off( 'resize', opts._carouselResizeThrottle );
        opts.slides.prependTo( opts.container );
        opts._carouselWrap.remove();
    }
};

})(jQuery);

/*! shuffle transition plugin for Cycle2;  version: 20140128 */
(function($) {
"use strict";

$.fn.cycle.transitions.shuffle = {

    transition: function( opts, currEl, nextEl, fwd, callback ) {
        $( nextEl ).css({
            display: 'block',
            visibility: 'visible'
        });
        var width = opts.container.css( 'overflow', 'visible' ).width();
        var speed = opts.speed / 2; // shuffle has 2 transitions
        var element = fwd ? currEl : nextEl;

        opts = opts.API.getSlideOpts( fwd ? opts.currSlide : opts.nextSlide );
        var props1 = { left:-width, top:15 };
        var props2 =  opts.slideCss || { left:0, top:0 };

        if ( opts.shuffleLeft !== undefined ) {
            props1.left = props1.left + parseInt(opts.shuffleLeft, 10) || 0;
        } 
        else if ( opts.shuffleRight !== undefined ) {
            props1.left = width + parseInt(opts.shuffleRight, 10) || 0;
        } 
        if ( opts.shuffleTop ) {
            props1.top = opts.shuffleTop;
        }

        // transition slide in 3 steps: move, re-zindex, move
        $( element )
            .animate( props1, speed, opts.easeIn || opts.easing )
            .queue( 'fx', $.proxy(reIndex, this))
            .animate( props2, speed, opts.easeOut || opts.easing, callback );

        function reIndex(nextFn) {
            /*jshint validthis:true */
            this.stack(opts, currEl, nextEl, fwd);
            nextFn();
        }
    },

    stack: function( opts, currEl, nextEl, fwd ) {
        var i, z;

        if (fwd) {
            opts.API.stackSlides( nextEl, currEl, fwd );
            // force curr slide to bottom of the stack
            $(currEl).css( 'zIndex', 1 );
        }
        else {
            z = 1;
            for (i = opts.nextSlide - 1; i >= 0; i--) {
                $(opts.slides[i]).css('zIndex', z++);
            }
            for (i = opts.slideCount - 1; i > opts.nextSlide; i--) {
                $(opts.slides[i]).css('zIndex', z++);
            }
            $(nextEl).css( 'zIndex', opts.maxZ );
            $(currEl).css( 'zIndex', opts.maxZ - 1 );
        }
    }
};

})(jQuery);

/*! tile transition plugin for Cycle2;  version: 20140128 */
(function ($) {
"use strict";

$.fn.cycle.transitions.tileSlide =
$.fn.cycle.transitions.tileBlind = {

    before: function( opts, curr, next, fwd ) {
        opts.API.stackSlides( curr, next, fwd );
        $(curr).css({
            display: 'block',
            visibility: 'visible'
        });
        opts.container.css('overflow', 'hidden');
        // set defaults
        opts.tileDelay = opts.tileDelay || opts.fx == 'tileSlide' ? 100 : 125;
        opts.tileCount = opts.tileCount || 7;
        opts.tileVertical = opts.tileVertical !== false;

        if (!opts.container.data('cycleTileInitialized')) {
            opts.container.on('cycle-destroyed', $.proxy(this.onDestroy, opts.API));
            opts.container.data('cycleTileInitialized', true);
        }
    },

    transition: function( opts, curr, next, fwd, callback ) {
        opts.slides.not(curr).not(next).css('visibility','hidden');

        var tiles = $();
        var $curr = $(curr), $next = $(next);
        var tile, tileWidth, tileHeight, lastTileWidth, lastTileHeight,
            num = opts.tileCount,
            vert = opts.tileVertical,
            height = opts.container.height(),
            width = opts.container.width();

        if ( vert ) {
            tileWidth = Math.floor(width / num);
            lastTileWidth = width - (tileWidth * (num - 1));
            tileHeight = lastTileHeight = height;
        }
        else {
            tileWidth = lastTileWidth = width;
            tileHeight = Math.floor(height / num);
            lastTileHeight = height - (tileHeight * (num - 1));
        }

        // opts.speed = opts.speed / 2;
        opts.container.find('.cycle-tiles-container').remove();

        var animCSS;
        var tileCSS = { left: 0, top: 0, overflow: 'hidden', position: 'absolute', margin: 0, padding: 0 };
        if ( vert ) {
            animCSS = opts.fx == 'tileSlide' ? { top: height } : { width: 0 };
        }
        else {
            animCSS = opts.fx == 'tileSlide' ? { left: width } : { height: 0 };
        }

        var tilesContainer = $('<div class="cycle-tiles-container"></div>');
        tilesContainer.css({
            zIndex: $curr.css('z-index'),
            overflow: 'visible',
            position: 'absolute', 
            top: 0,
            left: 0,
            direction: 'ltr' // #250
        });
        tilesContainer.insertBefore( next );

        for (var i = 0; i < num; i++) {
            tile = $('<div></div>')
            .css( tileCSS )
            .css({
                width:  ((num - 1 === i) ? lastTileWidth  : tileWidth),
                height: ((num - 1 === i) ? lastTileHeight : tileHeight),
                marginLeft: vert ? ((i * tileWidth)) : 0,
                marginTop:  vert ? 0 : (i * tileHeight)
            })
            .append($curr.clone().css({
                position: 'relative',
                maxWidth: 'none',
                width: $curr.width(),
                margin: 0, padding: 0,
                marginLeft: vert ? -(i * tileWidth) : 0,
                marginTop: vert ? 0 : -(i * tileHeight)
            }));
            tiles = tiles.add(tile);
        }

        tilesContainer.append(tiles);
        $curr.css('visibility','hidden');
        $next.css({
            opacity: 1,
            display: 'block',
            visibility: 'visible'
        });
        animateTile(fwd ? 0 : num - 1);
        
        opts._tileAniCallback = function() {
            $next.css({
                display: 'block',
                visibility: 'visible'
            });
            $curr.css('visibility','hidden');
            tilesContainer.remove();
            callback();
        };

        function animateTile(i) {
            tiles.eq(i).animate( animCSS, {
                duration: opts.speed,
                easing: opts.easing,
                complete: function () {
                    if (fwd ? (num - 1 === i) : (0 === i)) {
                        opts._tileAniCallback();
                    }
                }
            });

            setTimeout(function () {
                if (fwd ? (num - 1 !== i) : (0 !== i)) {
                    animateTile(fwd ? (i + 1) : (i - 1));
                }
            }, opts.tileDelay);
        }
    },

    // tx API impl
    stopTransition: function( opts ) {
        opts.container.find('*').stop( true, true );
        if (opts._tileAniCallback)
            opts._tileAniCallback();
    },

    // core API supplement
    onDestroy: function( e ) {
        var opts = this.opts();
        opts.container.find('.cycle-tiles-container').remove();
    }
};

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkVuZ2luZS5DeWNsZTIuanMiLCJqcXVlcnkuY3ljbGUyLmpzIiwianF1ZXJ5LmN5Y2xlMi5zd2lwZS5qcyIsImpxdWVyeS5jeWNsZTIuZmxpcC5qcyIsImpxdWVyeS5jeWNsZTIuY2Fyb3VzZWwuanMiLCJqcXVlcnkuY3ljbGUyLnNodWZmbGUuanMiLCJqcXVlcnkuY3ljbGUyLnRpbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDM2dEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IkVuZ2luZS5DeWNsZTIuanMiLCJzb3VyY2VzQ29udGVudCI6W251bGwsIi8qIVxyXG4qIGpRdWVyeSBDeWNsZTI7IHZlcnNpb246IDIuMS42IGJ1aWxkOiAyMDE0MTAwN1xyXG4qIGh0dHA6Ly9qcXVlcnkubWFsc3VwLmNvbS9jeWNsZTIvXHJcbiogQ29weXJpZ2h0IChjKSAyMDE0IE0uIEFsc3VwOyBEdWFsIGxpY2Vuc2VkOiBNSVQvR1BMXHJcbiovXHJcblxyXG4vKiBDeWNsZTIgY29yZSBlbmdpbmUgKi9cclxuOyhmdW5jdGlvbigkKSB7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHZlcnNpb24gPSAnMi4xLjYnO1xyXG5cclxuJC5mbi5jeWNsZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG4gICAgLy8gZml4IG1pc3Rha2VzIHdpdGggdGhlIHJlYWR5IHN0YXRlXHJcbiAgICB2YXIgbztcclxuICAgIGlmICggdGhpcy5sZW5ndGggPT09IDAgJiYgISQuaXNSZWFkeSApIHtcclxuICAgICAgICBvID0geyBzOiB0aGlzLnNlbGVjdG9yLCBjOiB0aGlzLmNvbnRleHQgfTtcclxuICAgICAgICAkLmZuLmN5Y2xlLmxvZygncmVxdWV1aW5nIHNsaWRlc2hvdyAoZG9tIG5vdCByZWFkeSknKTtcclxuICAgICAgICAkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAkKCBvLnMsIG8uYyApLmN5Y2xlKG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRhdGEsIG9wdHMsIHNob3J0TmFtZSwgdmFsO1xyXG4gICAgICAgIHZhciBjb250YWluZXIgPSAkKHRoaXMpO1xyXG4gICAgICAgIHZhciBsb2cgPSAkLmZuLmN5Y2xlLmxvZztcclxuXHJcbiAgICAgICAgaWYgKCBjb250YWluZXIuZGF0YSgnY3ljbGUub3B0cycpIClcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBhbHJlYWR5IGluaXRpYWxpemVkXHJcblxyXG4gICAgICAgIGlmICggY29udGFpbmVyLmRhdGEoJ2N5Y2xlLWxvZycpID09PSBmYWxzZSB8fCBcclxuICAgICAgICAgICAgKCBvcHRpb25zICYmIG9wdGlvbnMubG9nID09PSBmYWxzZSApIHx8XHJcbiAgICAgICAgICAgICggb3B0cyAmJiBvcHRzLmxvZyA9PT0gZmFsc2UpICkge1xyXG4gICAgICAgICAgICBsb2cgPSAkLm5vb3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsb2coJy0tYzIgaW5pdC0tJyk7XHJcbiAgICAgICAgZGF0YSA9IGNvbnRhaW5lci5kYXRhKCk7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIGFsbG93IHByb3BzIHRvIGJlIGFjY2Vzc2VkIHNhbnMgJ2N5Y2xlJyBwcmVmaXggYW5kIGxvZyB0aGUgb3ZlcnJpZGVzXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KHApICYmIC9eY3ljbGVbQS1aXSsvLnRlc3QocCkgKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBkYXRhW3BdO1xyXG4gICAgICAgICAgICAgICAgc2hvcnROYW1lID0gcC5tYXRjaCgvXmN5Y2xlKC4qKS8pWzFdLnJlcGxhY2UoL15bQS1aXS8sIGxvd2VyQ2FzZSk7XHJcbiAgICAgICAgICAgICAgICBsb2coc2hvcnROYW1lKyc6JywgdmFsLCAnKCcrdHlwZW9mIHZhbCArJyknKTtcclxuICAgICAgICAgICAgICAgIGRhdGFbc2hvcnROYW1lXSA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0cyA9ICQuZXh0ZW5kKCB7fSwgJC5mbi5jeWNsZS5kZWZhdWx0cywgZGF0YSwgb3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gICAgICAgIG9wdHMudGltZW91dElkID0gMDtcclxuICAgICAgICBvcHRzLnBhdXNlZCA9IG9wdHMucGF1c2VkIHx8IGZhbHNlOyAvLyAjNTdcclxuICAgICAgICBvcHRzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICBvcHRzLl9tYXhaID0gb3B0cy5tYXhaO1xyXG5cclxuICAgICAgICBvcHRzLkFQSSA9ICQuZXh0ZW5kICggeyBfY29udGFpbmVyOiBjb250YWluZXIgfSwgJC5mbi5jeWNsZS5BUEkgKTtcclxuICAgICAgICBvcHRzLkFQSS5sb2cgPSBsb2c7XHJcbiAgICAgICAgb3B0cy5BUEkudHJpZ2dlciA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGFyZ3MgKSB7XHJcbiAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLnRyaWdnZXIoIGV2ZW50TmFtZSwgYXJncyApO1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0cy5BUEk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29udGFpbmVyLmRhdGEoICdjeWNsZS5vcHRzJywgb3B0cyApO1xyXG4gICAgICAgIGNvbnRhaW5lci5kYXRhKCAnY3ljbGUuQVBJJywgb3B0cy5BUEkgKTtcclxuXHJcbiAgICAgICAgLy8gb3Bwb3J0dW5pdHkgZm9yIHBsdWdpbnMgdG8gbW9kaWZ5IG9wdHMgYW5kIEFQSVxyXG4gICAgICAgIG9wdHMuQVBJLnRyaWdnZXIoJ2N5Y2xlLWJvb3RzdHJhcCcsIFsgb3B0cywgb3B0cy5BUEkgXSk7XHJcblxyXG4gICAgICAgIG9wdHMuQVBJLmFkZEluaXRpYWxTbGlkZXMoKTtcclxuICAgICAgICBvcHRzLkFQSS5wcmVJbml0U2xpZGVzaG93KCk7XHJcblxyXG4gICAgICAgIGlmICggb3B0cy5zbGlkZXMubGVuZ3RoIClcclxuICAgICAgICAgICAgb3B0cy5BUEkuaW5pdFNsaWRlc2hvdygpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4kLmZuLmN5Y2xlLkFQSSA9IHtcclxuICAgIG9wdHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIuZGF0YSggJ2N5Y2xlLm9wdHMnICk7XHJcbiAgICB9LFxyXG4gICAgYWRkSW5pdGlhbFNsaWRlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHMoKTtcclxuICAgICAgICB2YXIgc2xpZGVzID0gb3B0cy5zbGlkZXM7XHJcbiAgICAgICAgb3B0cy5zbGlkZUNvdW50ID0gMDtcclxuICAgICAgICBvcHRzLnNsaWRlcyA9ICQoKTsgLy8gZW1wdHkgc2V0XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gYWRkIHNsaWRlcyB0aGF0IGFscmVhZHkgZXhpc3RcclxuICAgICAgICBzbGlkZXMgPSBzbGlkZXMuanF1ZXJ5ID8gc2xpZGVzIDogb3B0cy5jb250YWluZXIuZmluZCggc2xpZGVzICk7XHJcblxyXG4gICAgICAgIGlmICggb3B0cy5yYW5kb20gKSB7XHJcbiAgICAgICAgICAgIHNsaWRlcy5zb3J0KGZ1bmN0aW9uKCkge3JldHVybiBNYXRoLnJhbmRvbSgpIC0gMC41O30pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0cy5BUEkuYWRkKCBzbGlkZXMgKTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJlSW5pdFNsaWRlc2hvdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHMoKTtcclxuICAgICAgICBvcHRzLkFQSS50cmlnZ2VyKCdjeWNsZS1wcmUtaW5pdGlhbGl6ZScsIFsgb3B0cyBdKTtcclxuICAgICAgICB2YXIgdHggPSAkLmZuLmN5Y2xlLnRyYW5zaXRpb25zW29wdHMuZnhdO1xyXG4gICAgICAgIGlmICh0eCAmJiAkLmlzRnVuY3Rpb24odHgucHJlSW5pdCkpXHJcbiAgICAgICAgICAgIHR4LnByZUluaXQoIG9wdHMgKTtcclxuICAgICAgICBvcHRzLl9wcmVJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIHBvc3RJbml0U2xpZGVzaG93OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIG9wdHMuQVBJLnRyaWdnZXIoJ2N5Y2xlLXBvc3QtaW5pdGlhbGl6ZScsIFsgb3B0cyBdKTtcclxuICAgICAgICB2YXIgdHggPSAkLmZuLmN5Y2xlLnRyYW5zaXRpb25zW29wdHMuZnhdO1xyXG4gICAgICAgIGlmICh0eCAmJiAkLmlzRnVuY3Rpb24odHgucG9zdEluaXQpKVxyXG4gICAgICAgICAgICB0eC5wb3N0SW5pdCggb3B0cyApO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbml0U2xpZGVzaG93OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIHZhciBwYXVzZU9iaiA9IG9wdHMuY29udGFpbmVyO1xyXG4gICAgICAgIHZhciBzbGlkZU9wdHM7XHJcbiAgICAgICAgb3B0cy5BUEkuY2FsY0ZpcnN0U2xpZGUoKTtcclxuXHJcbiAgICAgICAgaWYgKCBvcHRzLmNvbnRhaW5lci5jc3MoJ3Bvc2l0aW9uJykgPT0gJ3N0YXRpYycgKVxyXG4gICAgICAgICAgICBvcHRzLmNvbnRhaW5lci5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XHJcblxyXG4gICAgICAgICQob3B0cy5zbGlkZXNbb3B0cy5jdXJyU2xpZGVdKS5jc3Moe1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZSdcclxuICAgICAgICB9KTtcclxuICAgICAgICBvcHRzLkFQSS5zdGFja1NsaWRlcyggb3B0cy5zbGlkZXNbb3B0cy5jdXJyU2xpZGVdLCBvcHRzLnNsaWRlc1tvcHRzLm5leHRTbGlkZV0sICFvcHRzLnJldmVyc2UgKTtcclxuXHJcbiAgICAgICAgaWYgKCBvcHRzLnBhdXNlT25Ib3ZlciApIHtcclxuICAgICAgICAgICAgLy8gYWxsb3cgcGF1c2VPbkhvdmVyIHRvIHNwZWNpZnkgYW4gZWxlbWVudFxyXG4gICAgICAgICAgICBpZiAoIG9wdHMucGF1c2VPbkhvdmVyICE9PSB0cnVlIClcclxuICAgICAgICAgICAgICAgIHBhdXNlT2JqID0gJCggb3B0cy5wYXVzZU9uSG92ZXIgKTtcclxuXHJcbiAgICAgICAgICAgIHBhdXNlT2JqLmhvdmVyKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKXsgb3B0cy5BUEkucGF1c2UoIHRydWUgKTsgfSwgXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpeyBvcHRzLkFQSS5yZXN1bWUoIHRydWUgKTsgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc3RhZ2UgaW5pdGlhbCB0cmFuc2l0aW9uXHJcbiAgICAgICAgaWYgKCBvcHRzLnRpbWVvdXQgKSB7XHJcbiAgICAgICAgICAgIHNsaWRlT3B0cyA9IG9wdHMuQVBJLmdldFNsaWRlT3B0cyggb3B0cy5jdXJyU2xpZGUgKTtcclxuICAgICAgICAgICAgb3B0cy5BUEkucXVldWVUcmFuc2l0aW9uKCBzbGlkZU9wdHMsIHNsaWRlT3B0cy50aW1lb3V0ICsgb3B0cy5kZWxheSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0cy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIG9wdHMuQVBJLnVwZGF0ZVZpZXcoIHRydWUgKTtcclxuICAgICAgICBvcHRzLkFQSS50cmlnZ2VyKCdjeWNsZS1pbml0aWFsaXplZCcsIFsgb3B0cyBdKTtcclxuICAgICAgICBvcHRzLkFQSS5wb3N0SW5pdFNsaWRlc2hvdygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwYXVzZTogZnVuY3Rpb24oIGhvdmVyICkge1xyXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCksXHJcbiAgICAgICAgICAgIHNsaWRlT3B0cyA9IG9wdHMuQVBJLmdldFNsaWRlT3B0cygpLFxyXG4gICAgICAgICAgICBhbHJlYWR5UGF1c2VkID0gb3B0cy5ob3ZlclBhdXNlZCB8fCBvcHRzLnBhdXNlZDtcclxuXHJcbiAgICAgICAgaWYgKCBob3ZlciApXHJcbiAgICAgICAgICAgIG9wdHMuaG92ZXJQYXVzZWQgPSB0cnVlOyBcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG9wdHMucGF1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKCAhIGFscmVhZHlQYXVzZWQgKSB7XHJcbiAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLmFkZENsYXNzKCdjeWNsZS1wYXVzZWQnKTtcclxuICAgICAgICAgICAgb3B0cy5BUEkudHJpZ2dlcignY3ljbGUtcGF1c2VkJywgWyBvcHRzIF0pLmxvZygnY3ljbGUtcGF1c2VkJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHNsaWRlT3B0cy50aW1lb3V0ICkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCBvcHRzLnRpbWVvdXRJZCApO1xyXG4gICAgICAgICAgICAgICAgb3B0cy50aW1lb3V0SWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgaG93IG11Y2ggdGltZSBpcyBsZWZ0IGZvciB0aGUgY3VycmVudCBzbGlkZVxyXG4gICAgICAgICAgICAgICAgb3B0cy5fcmVtYWluaW5nVGltZW91dCAtPSAoICQubm93KCkgLSBvcHRzLl9sYXN0UXVldWUgKTtcclxuICAgICAgICAgICAgICAgIGlmICggb3B0cy5fcmVtYWluaW5nVGltZW91dCA8IDAgfHwgaXNOYU4ob3B0cy5fcmVtYWluaW5nVGltZW91dCkgKVxyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMuX3JlbWFpbmluZ1RpbWVvdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc3VtZTogZnVuY3Rpb24oIGhvdmVyICkge1xyXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCksXHJcbiAgICAgICAgICAgIGFscmVhZHlSZXN1bWVkID0gIW9wdHMuaG92ZXJQYXVzZWQgJiYgIW9wdHMucGF1c2VkLFxyXG4gICAgICAgICAgICByZW1haW5pbmc7XHJcblxyXG4gICAgICAgIGlmICggaG92ZXIgKVxyXG4gICAgICAgICAgICBvcHRzLmhvdmVyUGF1c2VkID0gZmFsc2U7IFxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgb3B0cy5wYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICBcclxuICAgICAgICBpZiAoICEgYWxyZWFkeVJlc3VtZWQgKSB7XHJcbiAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLnJlbW92ZUNsYXNzKCdjeWNsZS1wYXVzZWQnKTtcclxuICAgICAgICAgICAgLy8gI2doLTIzMDsgaWYgYW4gYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzIHRoZW4gZG9uJ3QgcXVldWUgYSBuZXcgdHJhbnNpdGlvbjsgaXQgd2lsbFxyXG4gICAgICAgICAgICAvLyBoYXBwZW4gbmF0dXJhbGx5XHJcbiAgICAgICAgICAgIGlmICggb3B0cy5zbGlkZXMuZmlsdGVyKCc6YW5pbWF0ZWQnKS5sZW5ndGggPT09IDAgKVxyXG4gICAgICAgICAgICAgICAgb3B0cy5BUEkucXVldWVUcmFuc2l0aW9uKCBvcHRzLkFQSS5nZXRTbGlkZU9wdHMoKSwgb3B0cy5fcmVtYWluaW5nVGltZW91dCApO1xyXG4gICAgICAgICAgICBvcHRzLkFQSS50cmlnZ2VyKCdjeWNsZS1yZXN1bWVkJywgWyBvcHRzLCBvcHRzLl9yZW1haW5pbmdUaW1lb3V0IF0gKS5sb2coJ2N5Y2xlLXJlc3VtZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24oIHNsaWRlcywgcHJlcGVuZCApIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIHZhciBvbGRTbGlkZUNvdW50ID0gb3B0cy5zbGlkZUNvdW50O1xyXG4gICAgICAgIHZhciBzdGFydFNsaWRlc2hvdyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBsZW47XHJcblxyXG4gICAgICAgIGlmICggJC50eXBlKHNsaWRlcykgPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHNsaWRlcyA9ICQudHJpbSggc2xpZGVzICk7XHJcblxyXG4gICAgICAgICQoIHNsaWRlcyApLmVhY2goZnVuY3Rpb24oaSkge1xyXG4gICAgICAgICAgICB2YXIgc2xpZGVPcHRzO1xyXG4gICAgICAgICAgICB2YXIgc2xpZGUgPSAkKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwcmVwZW5kIClcclxuICAgICAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLnByZXBlbmQoIHNsaWRlICk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLmFwcGVuZCggc2xpZGUgKTtcclxuXHJcbiAgICAgICAgICAgIG9wdHMuc2xpZGVDb3VudCsrO1xyXG4gICAgICAgICAgICBzbGlkZU9wdHMgPSBvcHRzLkFQSS5idWlsZFNsaWRlT3B0cyggc2xpZGUgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcHJlcGVuZCApXHJcbiAgICAgICAgICAgICAgICBvcHRzLnNsaWRlcyA9ICQoIHNsaWRlICkuYWRkKCBvcHRzLnNsaWRlcyApO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBvcHRzLnNsaWRlcyA9IG9wdHMuc2xpZGVzLmFkZCggc2xpZGUgKTtcclxuXHJcbiAgICAgICAgICAgIG9wdHMuQVBJLmluaXRTbGlkZSggc2xpZGVPcHRzLCBzbGlkZSwgLS1vcHRzLl9tYXhaICk7XHJcblxyXG4gICAgICAgICAgICBzbGlkZS5kYXRhKCdjeWNsZS5vcHRzJywgc2xpZGVPcHRzKTtcclxuICAgICAgICAgICAgb3B0cy5BUEkudHJpZ2dlcignY3ljbGUtc2xpZGUtYWRkZWQnLCBbIG9wdHMsIHNsaWRlT3B0cywgc2xpZGUgXSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9wdHMuQVBJLnVwZGF0ZVZpZXcoIHRydWUgKTtcclxuXHJcbiAgICAgICAgc3RhcnRTbGlkZXNob3cgPSBvcHRzLl9wcmVJbml0aWFsaXplZCAmJiAob2xkU2xpZGVDb3VudCA8IDIgJiYgb3B0cy5zbGlkZUNvdW50ID49IDEpO1xyXG4gICAgICAgIGlmICggc3RhcnRTbGlkZXNob3cgKSB7XHJcbiAgICAgICAgICAgIGlmICggIW9wdHMuX2luaXRpYWxpemVkIClcclxuICAgICAgICAgICAgICAgIG9wdHMuQVBJLmluaXRTbGlkZXNob3coKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoIG9wdHMudGltZW91dCApIHtcclxuICAgICAgICAgICAgICAgIGxlbiA9IG9wdHMuc2xpZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gb3B0cy5yZXZlcnNlID8gbGVuIC0gMSA6IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFvcHRzLnRpbWVvdXRJZCApIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLkFQSS5xdWV1ZVRyYW5zaXRpb24oIG9wdHMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY2FsY0ZpcnN0U2xpZGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCk7XHJcbiAgICAgICAgdmFyIGZpcnN0U2xpZGVJbmRleDtcclxuICAgICAgICBmaXJzdFNsaWRlSW5kZXggPSBwYXJzZUludCggb3B0cy5zdGFydGluZ1NsaWRlIHx8IDAsIDEwICk7XHJcbiAgICAgICAgaWYgKGZpcnN0U2xpZGVJbmRleCA+PSBvcHRzLnNsaWRlcy5sZW5ndGggfHwgZmlyc3RTbGlkZUluZGV4IDwgMClcclxuICAgICAgICAgICAgZmlyc3RTbGlkZUluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgb3B0cy5jdXJyU2xpZGUgPSBmaXJzdFNsaWRlSW5kZXg7XHJcbiAgICAgICAgaWYgKCBvcHRzLnJldmVyc2UgKSB7XHJcbiAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gZmlyc3RTbGlkZUluZGV4IC0gMTtcclxuICAgICAgICAgICAgaWYgKG9wdHMubmV4dFNsaWRlIDwgMClcclxuICAgICAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gb3B0cy5zbGlkZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gZmlyc3RTbGlkZUluZGV4ICsgMTtcclxuICAgICAgICAgICAgaWYgKG9wdHMubmV4dFNsaWRlID09IG9wdHMuc2xpZGVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNhbGNOZXh0U2xpZGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCk7XHJcbiAgICAgICAgdmFyIHJvbGw7XHJcbiAgICAgICAgaWYgKCBvcHRzLnJldmVyc2UgKSB7XHJcbiAgICAgICAgICAgIHJvbGwgPSAob3B0cy5uZXh0U2xpZGUgLSAxKSA8IDA7XHJcbiAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gcm9sbCA/IG9wdHMuc2xpZGVDb3VudCAtIDEgOiBvcHRzLm5leHRTbGlkZS0xO1xyXG4gICAgICAgICAgICBvcHRzLmN1cnJTbGlkZSA9IHJvbGwgPyAwIDogb3B0cy5uZXh0U2xpZGUrMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJvbGwgPSAob3B0cy5uZXh0U2xpZGUgKyAxKSA9PSBvcHRzLnNsaWRlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gcm9sbCA/IDAgOiBvcHRzLm5leHRTbGlkZSsxO1xyXG4gICAgICAgICAgICBvcHRzLmN1cnJTbGlkZSA9IHJvbGwgPyBvcHRzLnNsaWRlcy5sZW5ndGgtMSA6IG9wdHMubmV4dFNsaWRlLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjYWxjVHg6IGZ1bmN0aW9uKCBzbGlkZU9wdHMsIG1hbnVhbCApIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHNsaWRlT3B0cztcclxuICAgICAgICB2YXIgdHg7XHJcblxyXG4gICAgICAgIGlmICggb3B0cy5fdGVtcEZ4IClcclxuICAgICAgICAgICAgdHggPSAkLmZuLmN5Y2xlLnRyYW5zaXRpb25zW29wdHMuX3RlbXBGeF07XHJcbiAgICAgICAgZWxzZSBpZiAoIG1hbnVhbCAmJiBvcHRzLm1hbnVhbEZ4IClcclxuICAgICAgICAgICAgdHggPSAkLmZuLmN5Y2xlLnRyYW5zaXRpb25zW29wdHMubWFudWFsRnhdO1xyXG5cclxuICAgICAgICBpZiAoICF0eCApXHJcbiAgICAgICAgICAgIHR4ID0gJC5mbi5jeWNsZS50cmFuc2l0aW9uc1tvcHRzLmZ4XTtcclxuXHJcbiAgICAgICAgb3B0cy5fdGVtcEZ4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9wdHMoKS5fdGVtcEZ4ID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKCF0eCkge1xyXG4gICAgICAgICAgICB0eCA9ICQuZm4uY3ljbGUudHJhbnNpdGlvbnMuZmFkZTtcclxuICAgICAgICAgICAgb3B0cy5BUEkubG9nKCdUcmFuc2l0aW9uIFwiJyArIG9wdHMuZnggKyAnXCIgbm90IGZvdW5kLiAgVXNpbmcgZmFkZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfSxcclxuXHJcbiAgICBwcmVwYXJlVHg6IGZ1bmN0aW9uKCBtYW51YWwsIGZ3ZCApIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIHZhciBhZnRlciwgY3VyciwgbmV4dCwgc2xpZGVPcHRzLCB0eDtcclxuXHJcbiAgICAgICAgaWYgKCBvcHRzLnNsaWRlQ291bnQgPCAyICkge1xyXG4gICAgICAgICAgICBvcHRzLnRpbWVvdXRJZCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBtYW51YWwgJiYgKCAhb3B0cy5idXN5IHx8IG9wdHMubWFudWFsVHJ1bXAgKSApIHtcclxuICAgICAgICAgICAgb3B0cy5BUEkuc3RvcFRyYW5zaXRpb24oKTtcclxuICAgICAgICAgICAgb3B0cy5idXN5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvcHRzLnRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgIG9wdHMudGltZW91dElkID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBvcHRzLmJ1c3kgKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKCBvcHRzLnRpbWVvdXRJZCA9PT0gMCAmJiAhbWFudWFsIClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBjdXJyID0gb3B0cy5zbGlkZXNbb3B0cy5jdXJyU2xpZGVdO1xyXG4gICAgICAgIG5leHQgPSBvcHRzLnNsaWRlc1tvcHRzLm5leHRTbGlkZV07XHJcbiAgICAgICAgc2xpZGVPcHRzID0gb3B0cy5BUEkuZ2V0U2xpZGVPcHRzKCBvcHRzLm5leHRTbGlkZSApO1xyXG4gICAgICAgIHR4ID0gb3B0cy5BUEkuY2FsY1R4KCBzbGlkZU9wdHMsIG1hbnVhbCApO1xyXG5cclxuICAgICAgICBvcHRzLl90eCA9IHR4O1xyXG5cclxuICAgICAgICBpZiAoIG1hbnVhbCAmJiBzbGlkZU9wdHMubWFudWFsU3BlZWQgIT09IHVuZGVmaW5lZCApXHJcbiAgICAgICAgICAgIHNsaWRlT3B0cy5zcGVlZCA9IHNsaWRlT3B0cy5tYW51YWxTcGVlZDtcclxuXHJcbiAgICAgICAgLy8gaWYgKCBvcHRzLm5leHRTbGlkZSA9PT0gb3B0cy5jdXJyU2xpZGUgKVxyXG4gICAgICAgIC8vICAgICBvcHRzLkFQSS5jYWxjTmV4dFNsaWRlKCk7XHJcblxyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0OlxyXG4gICAgICAgIC8vICAgICAgMS4gYWR2YW5jaW5nIHRvIGEgZGlmZmVyZW50IHNsaWRlXHJcbiAgICAgICAgLy8gICAgICAyLiB0aGlzIGlzIGVpdGhlciBhIG1hbnVhbCBldmVudCAocHJldi9uZXh0LCBwYWdlciwgY21kKSBvciBcclxuICAgICAgICAvLyAgICAgICAgICAgICAgYSB0aW1lciBldmVudCBhbmQgc2xpZGVzaG93IGlzIG5vdCBwYXVzZWRcclxuICAgICAgICBpZiAoIG9wdHMubmV4dFNsaWRlICE9IG9wdHMuY3VyclNsaWRlICYmIFxyXG4gICAgICAgICAgICAobWFudWFsIHx8ICghb3B0cy5wYXVzZWQgJiYgIW9wdHMuaG92ZXJQYXVzZWQgJiYgb3B0cy50aW1lb3V0KSApKSB7IC8vICM2MlxyXG5cclxuICAgICAgICAgICAgb3B0cy5BUEkudHJpZ2dlcignY3ljbGUtYmVmb3JlJywgWyBzbGlkZU9wdHMsIGN1cnIsIG5leHQsIGZ3ZCBdKTtcclxuICAgICAgICAgICAgaWYgKCB0eC5iZWZvcmUgKVxyXG4gICAgICAgICAgICAgICAgdHguYmVmb3JlKCBzbGlkZU9wdHMsIGN1cnIsIG5leHQsIGZ3ZCApO1xyXG5cclxuICAgICAgICAgICAgYWZ0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIG9wdHMuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gIzc2OyBiYWlsIGlmIHNsaWRlc2hvdyBoYXMgYmVlbiBkZXN0cm95ZWRcclxuICAgICAgICAgICAgICAgIGlmICghIG9wdHMuY29udGFpbmVyLmRhdGEoICdjeWNsZS5vcHRzJyApIClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR4LmFmdGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHR4LmFmdGVyKCBzbGlkZU9wdHMsIGN1cnIsIG5leHQsIGZ3ZCApO1xyXG4gICAgICAgICAgICAgICAgb3B0cy5BUEkudHJpZ2dlcignY3ljbGUtYWZ0ZXInLCBbIHNsaWRlT3B0cywgY3VyciwgbmV4dCwgZndkIF0pO1xyXG4gICAgICAgICAgICAgICAgb3B0cy5BUEkucXVldWVUcmFuc2l0aW9uKCBzbGlkZU9wdHMpO1xyXG4gICAgICAgICAgICAgICAgb3B0cy5BUEkudXBkYXRlVmlldyggdHJ1ZSApO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgb3B0cy5idXN5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHR4LnRyYW5zaXRpb24pXHJcbiAgICAgICAgICAgICAgICB0eC50cmFuc2l0aW9uKHNsaWRlT3B0cywgY3VyciwgbmV4dCwgZndkLCBhZnRlcik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG9wdHMuQVBJLmRvVHJhbnNpdGlvbiggc2xpZGVPcHRzLCBjdXJyLCBuZXh0LCBmd2QsIGFmdGVyKTtcclxuXHJcbiAgICAgICAgICAgIG9wdHMuQVBJLmNhbGNOZXh0U2xpZGUoKTtcclxuICAgICAgICAgICAgb3B0cy5BUEkudXBkYXRlVmlldygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuQVBJLnF1ZXVlVHJhbnNpdGlvbiggc2xpZGVPcHRzICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBwZXJmb3JtIHRoZSBhY3R1YWwgYW5pbWF0aW9uXHJcbiAgICBkb1RyYW5zaXRpb246IGZ1bmN0aW9uKCBzbGlkZU9wdHMsIGN1cnJFbCwgbmV4dEVsLCBmd2QsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSBzbGlkZU9wdHM7XHJcbiAgICAgICAgdmFyIGN1cnIgPSAkKGN1cnJFbCksIG5leHQgPSAkKG5leHRFbCk7XHJcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbmltSW4gaGFzIHNvbWV0aGluZyBzbyB0aGF0IGNhbGxiYWNrIGRvZXNuJ3QgdHJpZ2dlciBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICBuZXh0LmFuaW1hdGUob3B0cy5hbmltSW4gfHwgeyBvcGFjaXR5OiAxfSwgb3B0cy5zcGVlZCwgb3B0cy5lYXNlSW4gfHwgb3B0cy5lYXNpbmcsIGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBuZXh0LmNzcyhvcHRzLmNzc0JlZm9yZSB8fCB7fSk7XHJcbiAgICAgICAgY3Vyci5hbmltYXRlKG9wdHMuYW5pbU91dCB8fCB7fSwgb3B0cy5zcGVlZCwgb3B0cy5lYXNlT3V0IHx8IG9wdHMuZWFzaW5nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY3Vyci5jc3Mob3B0cy5jc3NBZnRlciB8fCB7fSk7XHJcbiAgICAgICAgICAgIGlmICghb3B0cy5zeW5jKSB7XHJcbiAgICAgICAgICAgICAgICBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG9wdHMuc3luYykge1xyXG4gICAgICAgICAgICBmbigpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcXVldWVUcmFuc2l0aW9uOiBmdW5jdGlvbiggc2xpZGVPcHRzLCBzcGVjaWZpY1RpbWVvdXQgKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHMoKTtcclxuICAgICAgICB2YXIgdGltZW91dCA9IHNwZWNpZmljVGltZW91dCAhPT0gdW5kZWZpbmVkID8gc3BlY2lmaWNUaW1lb3V0IDogc2xpZGVPcHRzLnRpbWVvdXQ7XHJcbiAgICAgICAgaWYgKG9wdHMubmV4dFNsaWRlID09PSAwICYmIC0tb3B0cy5sb29wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG9wdHMuQVBJLmxvZygndGVybWluYXRpbmc7IGxvb3A9MCcpO1xyXG4gICAgICAgICAgICBvcHRzLnRpbWVvdXQgPSAwO1xyXG4gICAgICAgICAgICBpZiAoIHRpbWVvdXQgKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMuQVBJLnRyaWdnZXIoJ2N5Y2xlLWZpbmlzaGVkJywgWyBvcHRzIF0pO1xyXG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRzLkFQSS50cmlnZ2VyKCdjeWNsZS1maW5pc2hlZCcsIFsgb3B0cyBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXNldCBuZXh0U2xpZGVcclxuICAgICAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSBvcHRzLmN1cnJTbGlkZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIG9wdHMuY29udGludWVBdXRvICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgIGlmICggb3B0cy5jb250aW51ZUF1dG8gPT09IGZhbHNlIHx8IFxyXG4gICAgICAgICAgICAgICAgKCQuaXNGdW5jdGlvbihvcHRzLmNvbnRpbnVlQXV0bykgJiYgb3B0cy5jb250aW51ZUF1dG8oKSA9PT0gZmFsc2UgKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0cy5BUEkubG9nKCd0ZXJtaW5hdGluZyBhdXRvbWF0aWMgdHJhbnNpdGlvbnMnKTtcclxuICAgICAgICAgICAgICAgIG9wdHMudGltZW91dCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoIG9wdHMudGltZW91dElkIClcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQob3B0cy50aW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggdGltZW91dCApIHtcclxuICAgICAgICAgICAgb3B0cy5fbGFzdFF1ZXVlID0gJC5ub3coKTtcclxuICAgICAgICAgICAgaWYgKCBzcGVjaWZpY1RpbWVvdXQgPT09IHVuZGVmaW5lZCApXHJcbiAgICAgICAgICAgICAgICBvcHRzLl9yZW1haW5pbmdUaW1lb3V0ID0gc2xpZGVPcHRzLnRpbWVvdXQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoICFvcHRzLnBhdXNlZCAmJiAhIG9wdHMuaG92ZXJQYXVzZWQgKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMuQVBJLnByZXBhcmVUeCggZmFsc2UsICFvcHRzLnJldmVyc2UgKTsgXHJcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3BUcmFuc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIGlmICggb3B0cy5zbGlkZXMuZmlsdGVyKCc6YW5pbWF0ZWQnKS5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgIG9wdHMuc2xpZGVzLnN0b3AoZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBvcHRzLkFQSS50cmlnZ2VyKCdjeWNsZS10cmFuc2l0aW9uLXN0b3BwZWQnLCBbIG9wdHMgXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG9wdHMuX3R4ICYmIG9wdHMuX3R4LnN0b3BUcmFuc2l0aW9uIClcclxuICAgICAgICAgICAgb3B0cy5fdHguc3RvcFRyYW5zaXRpb24oIG9wdHMgKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gYWR2YW5jZSBzbGlkZSBmb3J3YXJkIG9yIGJhY2tcclxuICAgIGFkdmFuY2VTbGlkZTogZnVuY3Rpb24oIHZhbCApIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIGNsZWFyVGltZW91dChvcHRzLnRpbWVvdXRJZCk7XHJcbiAgICAgICAgb3B0cy50aW1lb3V0SWQgPSAwO1xyXG4gICAgICAgIG9wdHMubmV4dFNsaWRlID0gb3B0cy5jdXJyU2xpZGUgKyB2YWw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG9wdHMubmV4dFNsaWRlIDwgMClcclxuICAgICAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSBvcHRzLnNsaWRlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKG9wdHMubmV4dFNsaWRlID49IG9wdHMuc2xpZGVzLmxlbmd0aClcclxuICAgICAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSAwO1xyXG5cclxuICAgICAgICBvcHRzLkFQSS5wcmVwYXJlVHgoIHRydWUsICB2YWwgPj0gMCApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgYnVpbGRTbGlkZU9wdHM6IGZ1bmN0aW9uKCBzbGlkZSApIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIHZhciB2YWwsIHNob3J0TmFtZTtcclxuICAgICAgICB2YXIgc2xpZGVPcHRzID0gc2xpZGUuZGF0YSgpIHx8IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gc2xpZGVPcHRzKSB7XHJcbiAgICAgICAgICAgIC8vIGFsbG93IHByb3BzIHRvIGJlIGFjY2Vzc2VkIHNhbnMgJ2N5Y2xlJyBwcmVmaXggYW5kIGxvZyB0aGUgb3ZlcnJpZGVzXHJcbiAgICAgICAgICAgIGlmIChzbGlkZU9wdHMuaGFzT3duUHJvcGVydHkocCkgJiYgL15jeWNsZVtBLVpdKy8udGVzdChwKSApIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHNsaWRlT3B0c1twXTtcclxuICAgICAgICAgICAgICAgIHNob3J0TmFtZSA9IHAubWF0Y2goL15jeWNsZSguKikvKVsxXS5yZXBsYWNlKC9eW0EtWl0vLCBsb3dlckNhc2UpO1xyXG4gICAgICAgICAgICAgICAgb3B0cy5BUEkubG9nKCdbJysob3B0cy5zbGlkZUNvdW50LTEpKyddJywgc2hvcnROYW1lKyc6JywgdmFsLCAnKCcrdHlwZW9mIHZhbCArJyknKTtcclxuICAgICAgICAgICAgICAgIHNsaWRlT3B0c1tzaG9ydE5hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzbGlkZU9wdHMgPSAkLmV4dGVuZCgge30sICQuZm4uY3ljbGUuZGVmYXVsdHMsIG9wdHMsIHNsaWRlT3B0cyApO1xyXG4gICAgICAgIHNsaWRlT3B0cy5zbGlkZU51bSA9IG9wdHMuc2xpZGVDb3VudDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgc2hvdWxkIGFsd2F5cyBiZSByZWFkIGZyb20gdGhlIG1hc3RlciBzdGF0ZSBvYmplY3RcclxuICAgICAgICAgICAgZGVsZXRlIHNsaWRlT3B0cy5BUEk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzbGlkZU9wdHMuc2xpZGVDb3VudDtcclxuICAgICAgICAgICAgZGVsZXRlIHNsaWRlT3B0cy5jdXJyU2xpZGU7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzbGlkZU9wdHMubmV4dFNsaWRlO1xyXG4gICAgICAgICAgICBkZWxldGUgc2xpZGVPcHRzLnNsaWRlcztcclxuICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgLy8gbm8gb3BcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNsaWRlT3B0cztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U2xpZGVPcHRzOiBmdW5jdGlvbiggaW5kZXggKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHMoKTtcclxuICAgICAgICBpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKVxyXG4gICAgICAgICAgICBpbmRleCA9IG9wdHMuY3VyclNsaWRlO1xyXG5cclxuICAgICAgICB2YXIgc2xpZGUgPSBvcHRzLnNsaWRlc1tpbmRleF07XHJcbiAgICAgICAgdmFyIHNsaWRlT3B0cyA9ICQoc2xpZGUpLmRhdGEoJ2N5Y2xlLm9wdHMnKTtcclxuICAgICAgICByZXR1cm4gJC5leHRlbmQoIHt9LCBvcHRzLCBzbGlkZU9wdHMgKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRTbGlkZTogZnVuY3Rpb24oIHNsaWRlT3B0cywgc2xpZGUsIHN1Z2dlc3RlZFppbmRleCApIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIHNsaWRlLmNzcyggc2xpZGVPcHRzLnNsaWRlQ3NzIHx8IHt9ICk7XHJcbiAgICAgICAgaWYgKCBzdWdnZXN0ZWRaaW5kZXggPiAwIClcclxuICAgICAgICAgICAgc2xpZGUuY3NzKCAnekluZGV4Jywgc3VnZ2VzdGVkWmluZGV4ICk7XHJcblxyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHNwZWVkIHNldHRpbmdzIGFyZSBzYW5lXHJcbiAgICAgICAgaWYgKCBpc05hTiggc2xpZGVPcHRzLnNwZWVkICkgKVxyXG4gICAgICAgICAgICBzbGlkZU9wdHMuc3BlZWQgPSAkLmZ4LnNwZWVkc1tzbGlkZU9wdHMuc3BlZWRdIHx8ICQuZnguc3BlZWRzLl9kZWZhdWx0O1xyXG4gICAgICAgIGlmICggIXNsaWRlT3B0cy5zeW5jIClcclxuICAgICAgICAgICAgc2xpZGVPcHRzLnNwZWVkID0gc2xpZGVPcHRzLnNwZWVkIC8gMjtcclxuXHJcbiAgICAgICAgc2xpZGUuYWRkQ2xhc3MoIG9wdHMuc2xpZGVDbGFzcyApO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVWaWV3OiBmdW5jdGlvbiggaXNBZnRlciwgaXNEdXJpbmcsIGZvcmNlRXZlbnQgKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHMoKTtcclxuICAgICAgICBpZiAoICFvcHRzLl9pbml0aWFsaXplZCApXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgc2xpZGVPcHRzID0gb3B0cy5BUEkuZ2V0U2xpZGVPcHRzKCk7XHJcbiAgICAgICAgdmFyIGN1cnJTbGlkZSA9IG9wdHMuc2xpZGVzWyBvcHRzLmN1cnJTbGlkZSBdO1xyXG5cclxuICAgICAgICBpZiAoICEgaXNBZnRlciAmJiBpc0R1cmluZyAhPT0gdHJ1ZSApIHtcclxuICAgICAgICAgICAgb3B0cy5BUEkudHJpZ2dlcignY3ljbGUtdXBkYXRlLXZpZXctYmVmb3JlJywgWyBvcHRzLCBzbGlkZU9wdHMsIGN1cnJTbGlkZSBdKTtcclxuICAgICAgICAgICAgaWYgKCBvcHRzLnVwZGF0ZVZpZXcgPCAwIClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggb3B0cy5zbGlkZUFjdGl2ZUNsYXNzICkge1xyXG4gICAgICAgICAgICBvcHRzLnNsaWRlcy5yZW1vdmVDbGFzcyggb3B0cy5zbGlkZUFjdGl2ZUNsYXNzIClcclxuICAgICAgICAgICAgICAgIC5lcSggb3B0cy5jdXJyU2xpZGUgKS5hZGRDbGFzcyggb3B0cy5zbGlkZUFjdGl2ZUNsYXNzICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGlzQWZ0ZXIgJiYgb3B0cy5oaWRlTm9uQWN0aXZlIClcclxuICAgICAgICAgICAgb3B0cy5zbGlkZXMuZmlsdGVyKCAnOm5vdCguJyArIG9wdHMuc2xpZGVBY3RpdmVDbGFzcyArICcpJyApLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcclxuXHJcbiAgICAgICAgaWYgKCBvcHRzLnVwZGF0ZVZpZXcgPT09IDAgKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRzLkFQSS50cmlnZ2VyKCdjeWNsZS11cGRhdGUtdmlldycsIFsgb3B0cywgc2xpZGVPcHRzLCBjdXJyU2xpZGUsIGlzQWZ0ZXIgXSk7XHJcbiAgICAgICAgICAgIH0sIHNsaWRlT3B0cy5zcGVlZCAvIChvcHRzLnN5bmMgPyAyIDogMSkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggb3B0cy51cGRhdGVWaWV3ICE9PSAwIClcclxuICAgICAgICAgICAgb3B0cy5BUEkudHJpZ2dlcignY3ljbGUtdXBkYXRlLXZpZXcnLCBbIG9wdHMsIHNsaWRlT3B0cywgY3VyclNsaWRlLCBpc0FmdGVyIF0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICggaXNBZnRlciApXHJcbiAgICAgICAgICAgIG9wdHMuQVBJLnRyaWdnZXIoJ2N5Y2xlLXVwZGF0ZS12aWV3LWFmdGVyJywgWyBvcHRzLCBzbGlkZU9wdHMsIGN1cnJTbGlkZSBdKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiggbmFtZSApIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIHZhciBzZWxlY3RvciA9IG9wdHNbbmFtZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgLy8gaWYgc2VsZWN0b3IgaXMgYSBjaGlsZCwgc2libGluZyBjb21iaW5hdG9yLCBhZGphbmNlbnQgc2VsZWN0b3IgdGhlbiB1c2UgZmluZCwgb3RoZXJ3aXNlIHF1ZXJ5IGZ1bGwgZG9tXHJcbiAgICAgICAgICAgIHJldHVybiAoL15cXHMqW1xcPnxcXCt8fl0vKS50ZXN0KCBzZWxlY3RvciApID8gb3B0cy5jb250YWluZXIuZmluZCggc2VsZWN0b3IgKSA6ICQoIHNlbGVjdG9yICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxlY3Rvci5qcXVlcnkpXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gJChzZWxlY3Rvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YWNrU2xpZGVzOiBmdW5jdGlvbiggY3VyciwgbmV4dCwgZndkICkge1xyXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCk7XHJcbiAgICAgICAgaWYgKCAhY3VyciApIHtcclxuICAgICAgICAgICAgY3VyciA9IG9wdHMuc2xpZGVzW29wdHMuY3VyclNsaWRlXTtcclxuICAgICAgICAgICAgbmV4dCA9IG9wdHMuc2xpZGVzW29wdHMubmV4dFNsaWRlXTtcclxuICAgICAgICAgICAgZndkID0gIW9wdHMucmV2ZXJzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHRoZSB6SW5kZXggZm9yIHRoZSBjb21tb24gY2FzZTpcclxuICAgICAgICAvLyBjdXJyIHNsaWRlIG9uIHRvcCwgIG5leHQgc2xpZGUgYmVuZWF0aCwgYW5kIHRoZSByZXN0IGluIG9yZGVyIHRvIGJlIHNob3duXHJcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsIG9wdHMubWF4Wik7XHJcblxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB6ID0gb3B0cy5tYXhaIC0gMjtcclxuICAgICAgICB2YXIgbGVuID0gb3B0cy5zbGlkZUNvdW50O1xyXG4gICAgICAgIGlmIChmd2QpIHtcclxuICAgICAgICAgICAgZm9yICggaSA9IG9wdHMuY3VyclNsaWRlICsgMTsgaSA8IGxlbjsgaSsrIClcclxuICAgICAgICAgICAgICAgICQoIG9wdHMuc2xpZGVzW2ldICkuY3NzKCAnekluZGV4Jywgei0tICk7XHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgb3B0cy5jdXJyU2xpZGU7IGkrKyApXHJcbiAgICAgICAgICAgICAgICAkKCBvcHRzLnNsaWRlc1tpXSApLmNzcyggJ3pJbmRleCcsIHotLSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICggaSA9IG9wdHMuY3VyclNsaWRlIC0gMTsgaSA+PSAwOyBpLS0gKVxyXG4gICAgICAgICAgICAgICAgJCggb3B0cy5zbGlkZXNbaV0gKS5jc3MoICd6SW5kZXgnLCB6LS0gKTtcclxuICAgICAgICAgICAgZm9yICggaSA9IGxlbiAtIDE7IGkgPiBvcHRzLmN1cnJTbGlkZTsgaS0tIClcclxuICAgICAgICAgICAgICAgICQoIG9wdHMuc2xpZGVzW2ldICkuY3NzKCAnekluZGV4Jywgei0tICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkKG5leHQpLmNzcygnekluZGV4Jywgb3B0cy5tYXhaIC0gMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFNsaWRlSW5kZXg6IGZ1bmN0aW9uKCBlbCApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRzKCkuc2xpZGVzLmluZGV4KCBlbCApO1xyXG4gICAgfVxyXG5cclxufTsgLy8gQVBJXHJcblxyXG4vLyBkZWZhdWx0IGxvZ2dlclxyXG4kLmZuLmN5Y2xlLmxvZyA9IGZ1bmN0aW9uIGxvZygpIHtcclxuICAgIC8qZ2xvYmFsIGNvbnNvbGU6dHJ1ZSAqL1xyXG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUubG9nKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbY3ljbGUyXSAnICsgQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcgJykgKTtcclxufTtcclxuXHJcbiQuZm4uY3ljbGUudmVyc2lvbiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0N5Y2xlMjogJyArIHZlcnNpb247IH07XHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcblxyXG5mdW5jdGlvbiBsb3dlckNhc2Uocykge1xyXG4gICAgcmV0dXJuIChzIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcblxyXG4vLyBleHBvc2UgdHJhbnNpdGlvbiBvYmplY3RcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucyA9IHtcclxuICAgIGN1c3RvbToge1xyXG4gICAgfSxcclxuICAgIG5vbmU6IHtcclxuICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uKCBvcHRzLCBjdXJyLCBuZXh0LCBmd2QgKSB7XHJcbiAgICAgICAgICAgIG9wdHMuQVBJLnN0YWNrU2xpZGVzKCBuZXh0LCBjdXJyLCBmd2QgKTtcclxuICAgICAgICAgICAgb3B0cy5jc3NCZWZvcmUgPSB7IG9wYWNpdHk6IDEsIHZpc2liaWxpdHk6ICd2aXNpYmxlJywgZGlzcGxheTogJ2Jsb2NrJyB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBmYWRlOiB7XHJcbiAgICAgICAgYmVmb3JlOiBmdW5jdGlvbiggb3B0cywgY3VyciwgbmV4dCwgZndkICkge1xyXG4gICAgICAgICAgICB2YXIgY3NzID0gb3B0cy5BUEkuZ2V0U2xpZGVPcHRzKCBvcHRzLm5leHRTbGlkZSApLnNsaWRlQ3NzIHx8IHt9O1xyXG4gICAgICAgICAgICBvcHRzLkFQSS5zdGFja1NsaWRlcyggY3VyciwgbmV4dCwgZndkICk7XHJcbiAgICAgICAgICAgIG9wdHMuY3NzQmVmb3JlID0gJC5leHRlbmQoY3NzLCB7IG9wYWNpdHk6IDAsIHZpc2liaWxpdHk6ICd2aXNpYmxlJywgZGlzcGxheTogJ2Jsb2NrJyB9KTtcclxuICAgICAgICAgICAgb3B0cy5hbmltSW4gPSB7IG9wYWNpdHk6IDEgfTtcclxuICAgICAgICAgICAgb3B0cy5hbmltT3V0ID0geyBvcGFjaXR5OiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGZhZGVvdXQ6IHtcclxuICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uKCBvcHRzICwgY3VyciwgbmV4dCwgZndkICkge1xyXG4gICAgICAgICAgICB2YXIgY3NzID0gb3B0cy5BUEkuZ2V0U2xpZGVPcHRzKCBvcHRzLm5leHRTbGlkZSApLnNsaWRlQ3NzIHx8IHt9O1xyXG4gICAgICAgICAgICBvcHRzLkFQSS5zdGFja1NsaWRlcyggY3VyciwgbmV4dCwgZndkICk7XHJcbiAgICAgICAgICAgIG9wdHMuY3NzQmVmb3JlID0gJC5leHRlbmQoY3NzLCB7IG9wYWNpdHk6IDEsIHZpc2liaWxpdHk6ICd2aXNpYmxlJywgZGlzcGxheTogJ2Jsb2NrJyB9KTtcclxuICAgICAgICAgICAgb3B0cy5hbmltT3V0ID0geyBvcGFjaXR5OiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNjcm9sbEhvcno6IHtcclxuICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uKCBvcHRzLCBjdXJyLCBuZXh0LCBmd2QgKSB7XHJcbiAgICAgICAgICAgIG9wdHMuQVBJLnN0YWNrU2xpZGVzKCBjdXJyLCBuZXh0LCBmd2QgKTtcclxuICAgICAgICAgICAgdmFyIHcgPSBvcHRzLmNvbnRhaW5lci5jc3MoJ292ZXJmbG93JywnaGlkZGVuJykud2lkdGgoKTtcclxuICAgICAgICAgICAgb3B0cy5jc3NCZWZvcmUgPSB7IGxlZnQ6IGZ3ZCA/IHcgOiAtIHcsIHRvcDogMCwgb3BhY2l0eTogMSwgdmlzaWJpbGl0eTogJ3Zpc2libGUnLCBkaXNwbGF5OiAnYmxvY2snIH07XHJcbiAgICAgICAgICAgIG9wdHMuY3NzQWZ0ZXIgPSB7IHpJbmRleDogb3B0cy5fbWF4WiAtIDIsIGxlZnQ6IDAgfTtcclxuICAgICAgICAgICAgb3B0cy5hbmltSW4gPSB7IGxlZnQ6IDAgfTtcclxuICAgICAgICAgICAgb3B0cy5hbmltT3V0ID0geyBsZWZ0OiBmd2QgPyAtdyA6IHcgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBAc2VlOiBodHRwOi8vanF1ZXJ5Lm1hbHN1cC5jb20vY3ljbGUyL2FwaVxyXG4kLmZuLmN5Y2xlLmRlZmF1bHRzID0ge1xyXG4gICAgYWxsb3dXcmFwOiAgICAgICAgdHJ1ZSxcclxuICAgIGF1dG9TZWxlY3RvcjogICAgICcuY3ljbGUtc2xpZGVzaG93W2RhdGEtY3ljbGUtYXV0by1pbml0IT1mYWxzZV0nLFxyXG4gICAgZGVsYXk6ICAgICAgICAgICAgMCxcclxuICAgIGVhc2luZzogICAgICAgICAgIG51bGwsXHJcbiAgICBmeDogICAgICAgICAgICAgICdmYWRlJyxcclxuICAgIGhpZGVOb25BY3RpdmU6ICAgIHRydWUsXHJcbiAgICBsb29wOiAgICAgICAgICAgICAwLFxyXG4gICAgbWFudWFsRng6ICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgbWFudWFsU3BlZWQ6ICAgICAgdW5kZWZpbmVkLFxyXG4gICAgbWFudWFsVHJ1bXA6ICAgICAgdHJ1ZSxcclxuICAgIG1heFo6ICAgICAgICAgICAgIDEwMCxcclxuICAgIHBhdXNlT25Ib3ZlcjogICAgIGZhbHNlLFxyXG4gICAgcmV2ZXJzZTogICAgICAgICAgZmFsc2UsXHJcbiAgICBzbGlkZUFjdGl2ZUNsYXNzOiAnY3ljbGUtc2xpZGUtYWN0aXZlJyxcclxuICAgIHNsaWRlQ2xhc3M6ICAgICAgICdjeWNsZS1zbGlkZScsXHJcbiAgICBzbGlkZUNzczogICAgICAgICB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IDAsIGxlZnQ6IDAgfSxcclxuICAgIHNsaWRlczogICAgICAgICAgJz4gaW1nJyxcclxuICAgIHNwZWVkOiAgICAgICAgICAgIDUwMCxcclxuICAgIHN0YXJ0aW5nU2xpZGU6ICAgIDAsXHJcbiAgICBzeW5jOiAgICAgICAgICAgICB0cnVlLFxyXG4gICAgdGltZW91dDogICAgICAgICAgNDAwMCxcclxuICAgIHVwZGF0ZVZpZXc6ICAgICAgIDBcclxufTtcclxuXHJcbi8vIGF1dG9tYXRpY2FsbHkgZmluZCBhbmQgcnVuIHNsaWRlc2hvd3NcclxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAkKCAkLmZuLmN5Y2xlLmRlZmF1bHRzLmF1dG9TZWxlY3RvciApLmN5Y2xlKCk7XHJcbn0pO1xyXG5cclxufSkoalF1ZXJ5KTtcclxuXHJcbi8qISBDeWNsZTIgYXV0b2hlaWdodCBwbHVnaW47IENvcHlyaWdodCAoYykgTS5BbHN1cCwgMjAxMjsgdmVyc2lvbjogMjAxMzA5MTMgKi9cclxuKGZ1bmN0aW9uKCQpIHtcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4kLmV4dGVuZCgkLmZuLmN5Y2xlLmRlZmF1bHRzLCB7XHJcbiAgICBhdXRvSGVpZ2h0OiAwLCAvLyBzZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGZhbHNlIGRpc2FibGVzIGF1dG9IZWlnaHQgbG9naWNcclxuICAgIGF1dG9IZWlnaHRTcGVlZDogMjUwLFxyXG4gICAgYXV0b0hlaWdodEVhc2luZzogbnVsbFxyXG59KTsgICAgXHJcblxyXG4kKGRvY3VtZW50KS5vbiggJ2N5Y2xlLWluaXRpYWxpemVkJywgZnVuY3Rpb24oIGUsIG9wdHMgKSB7XHJcbiAgICB2YXIgYXV0b0hlaWdodCA9IG9wdHMuYXV0b0hlaWdodDtcclxuICAgIHZhciB0ID0gJC50eXBlKCBhdXRvSGVpZ2h0ICk7XHJcbiAgICB2YXIgcmVzaXplVGhyb3R0bGUgPSBudWxsO1xyXG4gICAgdmFyIHJhdGlvO1xyXG5cclxuICAgIGlmICggdCAhPT0gJ3N0cmluZycgJiYgdCAhPT0gJ251bWJlcicgKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyBiaW5kIGV2ZW50c1xyXG4gICAgb3B0cy5jb250YWluZXIub24oICdjeWNsZS1zbGlkZS1hZGRlZCBjeWNsZS1zbGlkZS1yZW1vdmVkJywgaW5pdEF1dG9IZWlnaHQgKTtcclxuICAgIG9wdHMuY29udGFpbmVyLm9uKCAnY3ljbGUtZGVzdHJveWVkJywgb25EZXN0cm95ICk7XHJcblxyXG4gICAgaWYgKCBhdXRvSGVpZ2h0ID09ICdjb250YWluZXInICkge1xyXG4gICAgICAgIG9wdHMuY29udGFpbmVyLm9uKCAnY3ljbGUtYmVmb3JlJywgb25CZWZvcmUgKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCB0ID09PSAnc3RyaW5nJyAmJiAvXFxkK1xcOlxcZCsvLnRlc3QoIGF1dG9IZWlnaHQgKSApIHsgXHJcbiAgICAgICAgLy8gdXNlIHJhdGlvXHJcbiAgICAgICAgcmF0aW8gPSBhdXRvSGVpZ2h0Lm1hdGNoKC8oXFxkKylcXDooXFxkKykvKTtcclxuICAgICAgICByYXRpbyA9IHJhdGlvWzFdIC8gcmF0aW9bMl07XHJcbiAgICAgICAgb3B0cy5fYXV0b0hlaWdodFJhdGlvID0gcmF0aW87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgYXV0b0hlaWdodCBpcyBhIG51bWJlciB0aGVuIHdlIGRvbid0IG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIHNlbnRpbmVsXHJcbiAgICAvLyBpbmRleCBvbiByZXNpemVcclxuICAgIGlmICggdCAhPT0gJ251bWJlcicgKSB7XHJcbiAgICAgICAgLy8gYmluZCB1bmlxdWUgcmVzaXplIGhhbmRsZXIgcGVyIHNsaWRlc2hvdyAoc28gaXQgY2FuIGJlICdvZmYtZWQnIGluIG9uRGVzdHJveSlcclxuICAgICAgICBvcHRzLl9hdXRvSGVpZ2h0T25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCggcmVzaXplVGhyb3R0bGUgKTtcclxuICAgICAgICAgICAgcmVzaXplVGhyb3R0bGUgPSBzZXRUaW1lb3V0KCBvblJlc2l6ZSwgNTAgKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkKHdpbmRvdykub24oICdyZXNpemUgb3JpZW50YXRpb25jaGFuZ2UnLCBvcHRzLl9hdXRvSGVpZ2h0T25SZXNpemUgKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUaW1lb3V0KCBvblJlc2l6ZSwgMzAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcclxuICAgICAgICBpbml0QXV0b0hlaWdodCggZSwgb3B0cyApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGluaXRBdXRvSGVpZ2h0KCBlLCBvcHRzICkge1xyXG4gICAgdmFyIGNsb25lLCBoZWlnaHQsIHNlbnRpbmVsSW5kZXg7XHJcbiAgICB2YXIgYXV0b0hlaWdodCA9IG9wdHMuYXV0b0hlaWdodDtcclxuXHJcbiAgICBpZiAoIGF1dG9IZWlnaHQgPT0gJ2NvbnRhaW5lcicgKSB7XHJcbiAgICAgICAgaGVpZ2h0ID0gJCggb3B0cy5zbGlkZXNbIG9wdHMuY3VyclNsaWRlIF0gKS5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgIG9wdHMuY29udGFpbmVyLmhlaWdodCggaGVpZ2h0ICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggb3B0cy5fYXV0b0hlaWdodFJhdGlvICkgeyBcclxuICAgICAgICBvcHRzLmNvbnRhaW5lci5oZWlnaHQoIG9wdHMuY29udGFpbmVyLndpZHRoKCkgLyBvcHRzLl9hdXRvSGVpZ2h0UmF0aW8gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBhdXRvSGVpZ2h0ID09PSAnY2FsYycgfHwgKCAkLnR5cGUoIGF1dG9IZWlnaHQgKSA9PSAnbnVtYmVyJyAmJiBhdXRvSGVpZ2h0ID49IDAgKSApIHtcclxuICAgICAgICBpZiAoIGF1dG9IZWlnaHQgPT09ICdjYWxjJyApXHJcbiAgICAgICAgICAgIHNlbnRpbmVsSW5kZXggPSBjYWxjU2VudGluZWxJbmRleCggZSwgb3B0cyApO1xyXG4gICAgICAgIGVsc2UgaWYgKCBhdXRvSGVpZ2h0ID49IG9wdHMuc2xpZGVzLmxlbmd0aCApXHJcbiAgICAgICAgICAgIHNlbnRpbmVsSW5kZXggPSAwO1xyXG4gICAgICAgIGVsc2UgXHJcbiAgICAgICAgICAgIHNlbnRpbmVsSW5kZXggPSBhdXRvSGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBvbmx5IHJlY3JlYXRlIHNlbnRpbmVsIGlmIGluZGV4IGlzIGRpZmZlcmVudFxyXG4gICAgICAgIGlmICggc2VudGluZWxJbmRleCA9PSBvcHRzLl9zZW50aW5lbEluZGV4IClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBvcHRzLl9zZW50aW5lbEluZGV4ID0gc2VudGluZWxJbmRleDtcclxuICAgICAgICBpZiAoIG9wdHMuX3NlbnRpbmVsIClcclxuICAgICAgICAgICAgb3B0cy5fc2VudGluZWwucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIC8vIGNsb25lIGV4aXN0aW5nIHNsaWRlIGFzIHNlbnRpbmVsXHJcbiAgICAgICAgY2xvbmUgPSAkKCBvcHRzLnNsaWRlc1sgc2VudGluZWxJbmRleCBdLmNsb25lTm9kZSh0cnVlKSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vICM1MDsgcmVtb3ZlIHNwZWNpYWwgYXR0cmlidXRlcyBmcm9tIGNsb25lZCBjb250ZW50XHJcbiAgICAgICAgY2xvbmUucmVtb3ZlQXR0ciggJ2lkIG5hbWUgcmVsJyApLmZpbmQoICdbaWRdLFtuYW1lXSxbcmVsXScgKS5yZW1vdmVBdHRyKCAnaWQgbmFtZSByZWwnICk7XHJcblxyXG4gICAgICAgIGNsb25lLmNzcyh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhdGljJyxcclxuICAgICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcclxuICAgICAgICB9KS5wcmVwZW5kVG8oIG9wdHMuY29udGFpbmVyICkuYWRkQ2xhc3MoJ2N5Y2xlLXNlbnRpbmVsIGN5Y2xlLXNsaWRlJykucmVtb3ZlQ2xhc3MoJ2N5Y2xlLXNsaWRlLWFjdGl2ZScpO1xyXG4gICAgICAgIGNsb25lLmZpbmQoICcqJyApLmNzcyggJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyApO1xyXG5cclxuICAgICAgICBvcHRzLl9zZW50aW5lbCA9IGNsb25lO1xyXG4gICAgfVxyXG59ICAgIFxyXG5cclxuZnVuY3Rpb24gY2FsY1NlbnRpbmVsSW5kZXgoIGUsIG9wdHMgKSB7XHJcbiAgICB2YXIgaW5kZXggPSAwLCBtYXggPSAtMTtcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgdGFsbGVzdCBzbGlkZSBpbmRleFxyXG4gICAgb3B0cy5zbGlkZXMuZWFjaChmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgdmFyIGggPSAkKHRoaXMpLmhlaWdodCgpO1xyXG4gICAgICAgIGlmICggaCA+IG1heCApIHtcclxuICAgICAgICAgICAgbWF4ID0gaDtcclxuICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGluZGV4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkJlZm9yZSggZSwgb3B0cywgb3V0Z29pbmcsIGluY29taW5nLCBmb3J3YXJkICkge1xyXG4gICAgdmFyIGggPSAkKGluY29taW5nKS5vdXRlckhlaWdodCgpO1xyXG4gICAgb3B0cy5jb250YWluZXIuYW5pbWF0ZSggeyBoZWlnaHQ6IGggfSwgb3B0cy5hdXRvSGVpZ2h0U3BlZWQsIG9wdHMuYXV0b0hlaWdodEVhc2luZyApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkRlc3Ryb3koIGUsIG9wdHMgKSB7XHJcbiAgICBpZiAoIG9wdHMuX2F1dG9IZWlnaHRPblJlc2l6ZSApIHtcclxuICAgICAgICAkKHdpbmRvdykub2ZmKCAncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlJywgb3B0cy5fYXV0b0hlaWdodE9uUmVzaXplICk7XHJcbiAgICAgICAgb3B0cy5fYXV0b0hlaWdodE9uUmVzaXplID0gbnVsbDtcclxuICAgIH1cclxuICAgIG9wdHMuY29udGFpbmVyLm9mZiggJ2N5Y2xlLXNsaWRlLWFkZGVkIGN5Y2xlLXNsaWRlLXJlbW92ZWQnLCBpbml0QXV0b0hlaWdodCApO1xyXG4gICAgb3B0cy5jb250YWluZXIub2ZmKCAnY3ljbGUtZGVzdHJveWVkJywgb25EZXN0cm95ICk7XHJcbiAgICBvcHRzLmNvbnRhaW5lci5vZmYoICdjeWNsZS1iZWZvcmUnLCBvbkJlZm9yZSApO1xyXG5cclxuICAgIGlmICggb3B0cy5fc2VudGluZWwgKSB7XHJcbiAgICAgICAgb3B0cy5fc2VudGluZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgb3B0cy5fc2VudGluZWwgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG59KShqUXVlcnkpO1xyXG5cclxuLyohIGNhcHRpb24gcGx1Z2luIGZvciBDeWNsZTI7ICB2ZXJzaW9uOiAyMDEzMDMwNiAqL1xyXG4oZnVuY3Rpb24oJCkge1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbiQuZXh0ZW5kKCQuZm4uY3ljbGUuZGVmYXVsdHMsIHtcclxuICAgIGNhcHRpb246ICAgICAgICAgICc+IC5jeWNsZS1jYXB0aW9uJyxcclxuICAgIGNhcHRpb25UZW1wbGF0ZTogICd7e3NsaWRlTnVtfX0gLyB7e3NsaWRlQ291bnR9fScsXHJcbiAgICBvdmVybGF5OiAgICAgICAgICAnPiAuY3ljbGUtb3ZlcmxheScsXHJcbiAgICBvdmVybGF5VGVtcGxhdGU6ICAnPGRpdj57e3RpdGxlfX08L2Rpdj48ZGl2Pnt7ZGVzY319PC9kaXY+JyxcclxuICAgIGNhcHRpb25Nb2R1bGU6ICAgICdjYXB0aW9uJ1xyXG59KTsgICAgXHJcblxyXG4kKGRvY3VtZW50KS5vbiggJ2N5Y2xlLXVwZGF0ZS12aWV3JywgZnVuY3Rpb24oIGUsIG9wdHMsIHNsaWRlT3B0cywgY3VyclNsaWRlICkge1xyXG4gICAgaWYgKCBvcHRzLmNhcHRpb25Nb2R1bGUgIT09ICdjYXB0aW9uJyApXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIGVsO1xyXG4gICAgJC5lYWNoKFsnY2FwdGlvbicsJ292ZXJsYXknXSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzOyBcclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBzbGlkZU9wdHNbbmFtZSsnVGVtcGxhdGUnXTtcclxuICAgICAgICB2YXIgZWwgPSBvcHRzLkFQSS5nZXRDb21wb25lbnQoIG5hbWUgKTtcclxuICAgICAgICBpZiggZWwubGVuZ3RoICYmIHRlbXBsYXRlICkge1xyXG4gICAgICAgICAgICBlbC5odG1sKCBvcHRzLkFQSS50bXBsKCB0ZW1wbGF0ZSwgc2xpZGVPcHRzLCBvcHRzLCBjdXJyU2xpZGUgKSApO1xyXG4gICAgICAgICAgICBlbC5zaG93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuJChkb2N1bWVudCkub24oICdjeWNsZS1kZXN0cm95ZWQnLCBmdW5jdGlvbiggZSwgb3B0cyApIHtcclxuICAgIHZhciBlbDtcclxuICAgICQuZWFjaChbJ2NhcHRpb24nLCdvdmVybGF5J10sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcywgdGVtcGxhdGUgPSBvcHRzW25hbWUrJ1RlbXBsYXRlJ107XHJcbiAgICAgICAgaWYgKCBvcHRzW25hbWVdICYmIHRlbXBsYXRlICkge1xyXG4gICAgICAgICAgICBlbCA9IG9wdHMuQVBJLmdldENvbXBvbmVudCggJ2NhcHRpb24nICk7XHJcbiAgICAgICAgICAgIGVsLmVtcHR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxufSkoalF1ZXJ5KTtcclxuXHJcbi8qISBjb21tYW5kIHBsdWdpbiBmb3IgQ3ljbGUyOyAgdmVyc2lvbjogMjAxNDA0MTUgKi9cclxuKGZ1bmN0aW9uKCQpIHtcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgYzIgPSAkLmZuLmN5Y2xlO1xyXG5cclxuJC5mbi5jeWNsZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG4gICAgdmFyIGNtZCwgY21kRm4sIG9wdHM7XHJcbiAgICB2YXIgYXJncyA9ICQubWFrZUFycmF5KCBhcmd1bWVudHMgKTtcclxuXHJcbiAgICBpZiAoICQudHlwZSggb3B0aW9ucyApID09ICdudW1iZXInICkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN5Y2xlKCAnZ290bycsIG9wdGlvbnMgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoICQudHlwZSggb3B0aW9ucyApID09ICdzdHJpbmcnICkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBjbWRBcmdzO1xyXG4gICAgICAgICAgICBjbWQgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBvcHRzID0gJCh0aGlzKS5kYXRhKCdjeWNsZS5vcHRzJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9wdHMgPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIGMyLmxvZygnc2xpZGVzaG93IG11c3QgYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHNlbmRpbmcgY29tbWFuZHM7IFwiJyArIGNtZCArICdcIiBpZ25vcmVkJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbWQgPSBjbWQgPT0gJ2dvdG8nID8gJ2p1bXAnIDogY21kOyAvLyBpc3N1ZSAjMzsgY2hhbmdlICdnb3RvJyB0byAnanVtcCcgaW50ZXJuYWxseVxyXG4gICAgICAgICAgICAgICAgY21kRm4gPSBvcHRzLkFQSVsgY21kIF07XHJcbiAgICAgICAgICAgICAgICBpZiAoICQuaXNGdW5jdGlvbiggY21kRm4gKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNtZEFyZ3MgPSAkLm1ha2VBcnJheSggYXJncyApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNtZEFyZ3Muc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY21kRm4uYXBwbHkoIG9wdHMuQVBJLCBjbWRBcmdzICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjMi5sb2coICd1bmtub3duIGNvbW1hbmQ6ICcsIGNtZCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYzIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gY29weSBwcm9wc1xyXG4kLmV4dGVuZCggJC5mbi5jeWNsZSwgYzIgKTtcclxuXHJcbiQuZXh0ZW5kKCBjMi5BUEksIHtcclxuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCk7XHJcbiAgICAgICAgaWYgKCBvcHRzLmJ1c3kgJiYgISBvcHRzLm1hbnVhbFRydW1wIClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgY291bnQgPSBvcHRzLnJldmVyc2UgPyAtMSA6IDE7XHJcbiAgICAgICAgaWYgKCBvcHRzLmFsbG93V3JhcCA9PT0gZmFsc2UgJiYgKCBvcHRzLmN1cnJTbGlkZSArIGNvdW50ICkgPj0gb3B0cy5zbGlkZUNvdW50IClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBvcHRzLkFQSS5hZHZhbmNlU2xpZGUoIGNvdW50ICk7XHJcbiAgICAgICAgb3B0cy5BUEkudHJpZ2dlcignY3ljbGUtbmV4dCcsIFsgb3B0cyBdKS5sb2coJ2N5Y2xlLW5leHQnKTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJldjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHMoKTtcclxuICAgICAgICBpZiAoIG9wdHMuYnVzeSAmJiAhIG9wdHMubWFudWFsVHJ1bXAgKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGNvdW50ID0gb3B0cy5yZXZlcnNlID8gMSA6IC0xO1xyXG4gICAgICAgIGlmICggb3B0cy5hbGxvd1dyYXAgPT09IGZhbHNlICYmICggb3B0cy5jdXJyU2xpZGUgKyBjb3VudCApIDwgMCApXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgb3B0cy5BUEkuYWR2YW5jZVNsaWRlKCBjb3VudCApO1xyXG4gICAgICAgIG9wdHMuQVBJLnRyaWdnZXIoJ2N5Y2xlLXByZXYnLCBbIG9wdHMgXSkubG9nKCdjeWNsZS1wcmV2Jyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcCgpOyAvLyMyMDRcclxuXHJcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHMoKTtcclxuICAgICAgICB2YXIgY2xlYW4gPSAkLmlzRnVuY3Rpb24oICQuX2RhdGEgKSA/ICQuX2RhdGEgOiAkLm5vb3A7ICAvLyBoYWNrIGZvciAjMTg0IGFuZCAjMjAxXHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KG9wdHMudGltZW91dElkKTtcclxuICAgICAgICBvcHRzLnRpbWVvdXRJZCA9IDA7XHJcbiAgICAgICAgb3B0cy5BUEkuc3RvcCgpO1xyXG4gICAgICAgIG9wdHMuQVBJLnRyaWdnZXIoICdjeWNsZS1kZXN0cm95ZWQnLCBbIG9wdHMgXSApLmxvZygnY3ljbGUtZGVzdHJveWVkJyk7XHJcbiAgICAgICAgb3B0cy5jb250YWluZXIucmVtb3ZlRGF0YSgpO1xyXG4gICAgICAgIGNsZWFuKCBvcHRzLmNvbnRhaW5lclswXSwgJ3BhcnNlZEF0dHJzJywgZmFsc2UgKTtcclxuXHJcbiAgICAgICAgLy8gIzc1OyByZW1vdmUgaW5saW5lIHN0eWxlc1xyXG4gICAgICAgIGlmICggISBvcHRzLnJldGFpblN0eWxlc09uRGVzdHJveSApIHtcclxuICAgICAgICAgICAgb3B0cy5jb250YWluZXIucmVtb3ZlQXR0ciggJ3N0eWxlJyApO1xyXG4gICAgICAgICAgICBvcHRzLnNsaWRlcy5yZW1vdmVBdHRyKCAnc3R5bGUnICk7XHJcbiAgICAgICAgICAgIG9wdHMuc2xpZGVzLnJlbW92ZUNsYXNzKCBvcHRzLnNsaWRlQWN0aXZlQ2xhc3MgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0cy5zbGlkZXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHNsaWRlID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgc2xpZGUucmVtb3ZlRGF0YSgpO1xyXG4gICAgICAgICAgICBzbGlkZS5yZW1vdmVDbGFzcyggb3B0cy5zbGlkZUNsYXNzICk7XHJcbiAgICAgICAgICAgIGNsZWFuKCB0aGlzLCAncGFyc2VkQXR0cnMnLCBmYWxzZSApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBqdW1wOiBmdW5jdGlvbiggaW5kZXgsIGZ4ICkge1xyXG4gICAgICAgIC8vIGdvIHRvIHRoZSByZXF1ZXN0ZWQgc2xpZGVcclxuICAgICAgICB2YXIgZndkO1xyXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCk7XHJcbiAgICAgICAgaWYgKCBvcHRzLmJ1c3kgJiYgISBvcHRzLm1hbnVhbFRydW1wIClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBudW0gPSBwYXJzZUludCggaW5kZXgsIDEwICk7XHJcbiAgICAgICAgaWYgKGlzTmFOKG51bSkgfHwgbnVtIDwgMCB8fCBudW0gPj0gb3B0cy5zbGlkZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG9wdHMuQVBJLmxvZygnZ290bzogaW52YWxpZCBzbGlkZSBpbmRleDogJyArIG51bSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG51bSA9PSBvcHRzLmN1cnJTbGlkZSkge1xyXG4gICAgICAgICAgICBvcHRzLkFQSS5sb2coJ2dvdG86IHNraXBwaW5nLCBhbHJlYWR5IG9uIHNsaWRlJywgbnVtKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRzLm5leHRTbGlkZSA9IG51bTtcclxuICAgICAgICBjbGVhclRpbWVvdXQob3B0cy50aW1lb3V0SWQpO1xyXG4gICAgICAgIG9wdHMudGltZW91dElkID0gMDtcclxuICAgICAgICBvcHRzLkFQSS5sb2coJ2dvdG86ICcsIG51bSwgJyAoemVyby1pbmRleCknKTtcclxuICAgICAgICBmd2QgPSBvcHRzLmN1cnJTbGlkZSA8IG9wdHMubmV4dFNsaWRlO1xyXG4gICAgICAgIG9wdHMuX3RlbXBGeCA9IGZ4O1xyXG4gICAgICAgIG9wdHMuQVBJLnByZXBhcmVUeCggdHJ1ZSwgZndkICk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCk7XHJcbiAgICAgICAgdmFyIHBhdXNlT2JqID0gb3B0cy5jb250YWluZXI7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KG9wdHMudGltZW91dElkKTtcclxuICAgICAgICBvcHRzLnRpbWVvdXRJZCA9IDA7XHJcbiAgICAgICAgb3B0cy5BUEkuc3RvcFRyYW5zaXRpb24oKTtcclxuICAgICAgICBpZiAoIG9wdHMucGF1c2VPbkhvdmVyICkge1xyXG4gICAgICAgICAgICBpZiAoIG9wdHMucGF1c2VPbkhvdmVyICE9PSB0cnVlIClcclxuICAgICAgICAgICAgICAgIHBhdXNlT2JqID0gJCggb3B0cy5wYXVzZU9uSG92ZXIgKTtcclxuICAgICAgICAgICAgcGF1c2VPYmoub2ZmKCdtb3VzZWVudGVyIG1vdXNlbGVhdmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0cy5BUEkudHJpZ2dlcignY3ljbGUtc3RvcHBlZCcsIFsgb3B0cyBdKS5sb2coJ2N5Y2xlLXN0b3BwZWQnKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVpbml0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIG9wdHMuQVBJLmRlc3Ryb3koKTtcclxuICAgICAgICBvcHRzLmNvbnRhaW5lci5jeWNsZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCBpbmRleCApIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIHZhciBzbGlkZSwgc2xpZGVUb1JlbW92ZSwgc2xpZGVzID0gW10sIHNsaWRlTnVtID0gMTtcclxuICAgICAgICBmb3IgKCB2YXIgaT0wOyBpIDwgb3B0cy5zbGlkZXMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgIHNsaWRlID0gb3B0cy5zbGlkZXNbaV07XHJcbiAgICAgICAgICAgIGlmICggaSA9PSBpbmRleCApIHtcclxuICAgICAgICAgICAgICAgIHNsaWRlVG9SZW1vdmUgPSBzbGlkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNsaWRlcy5wdXNoKCBzbGlkZSApO1xyXG4gICAgICAgICAgICAgICAgJCggc2xpZGUgKS5kYXRhKCdjeWNsZS5vcHRzJykuc2xpZGVOdW0gPSBzbGlkZU51bTtcclxuICAgICAgICAgICAgICAgIHNsaWRlTnVtKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBzbGlkZVRvUmVtb3ZlICkge1xyXG4gICAgICAgICAgICBvcHRzLnNsaWRlcyA9ICQoIHNsaWRlcyApO1xyXG4gICAgICAgICAgICBvcHRzLnNsaWRlQ291bnQtLTtcclxuICAgICAgICAgICAgJCggc2xpZGVUb1JlbW92ZSApLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gb3B0cy5jdXJyU2xpZGUpXHJcbiAgICAgICAgICAgICAgICBvcHRzLkFQSS5hZHZhbmNlU2xpZGUoIDEgKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoIGluZGV4IDwgb3B0cy5jdXJyU2xpZGUgKVxyXG4gICAgICAgICAgICAgICAgb3B0cy5jdXJyU2xpZGUtLTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgb3B0cy5jdXJyU2xpZGUrKztcclxuXHJcbiAgICAgICAgICAgIG9wdHMuQVBJLnRyaWdnZXIoJ2N5Y2xlLXNsaWRlLXJlbW92ZWQnLCBbIG9wdHMsIGluZGV4LCBzbGlkZVRvUmVtb3ZlIF0pLmxvZygnY3ljbGUtc2xpZGUtcmVtb3ZlZCcpO1xyXG4gICAgICAgICAgICBvcHRzLkFQSS51cGRhdGVWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG4vLyBsaXN0ZW4gZm9yIGNsaWNrcyBvbiBlbGVtZW50cyB3aXRoIGRhdGEtY3ljbGUtY21kIGF0dHJpYnV0ZVxyXG4kKGRvY3VtZW50KS5vbignY2xpY2suY3ljbGUnLCAnW2RhdGEtY3ljbGUtY21kXScsIGZ1bmN0aW9uKGUpIHtcclxuICAgIC8vIGlzc3VlIGN5Y2xlIGNvbW1hbmRcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIHZhciBlbCA9ICQodGhpcyk7XHJcbiAgICB2YXIgY29tbWFuZCA9IGVsLmRhdGEoJ2N5Y2xlLWNtZCcpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBlbC5kYXRhKCdjeWNsZS1jb250ZXh0JykgfHwgJy5jeWNsZS1zbGlkZXNob3cnO1xyXG4gICAgJChjb250ZXh0KS5jeWNsZShjb21tYW5kLCBlbC5kYXRhKCdjeWNsZS1hcmcnKSk7XHJcbn0pO1xyXG5cclxuXHJcbn0pKGpRdWVyeSk7XHJcblxyXG4vKiEgaGFzaCBwbHVnaW4gZm9yIEN5Y2xlMjsgIHZlcnNpb246IDIwMTMwOTA1ICovXHJcbihmdW5jdGlvbigkKSB7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuJChkb2N1bWVudCkub24oICdjeWNsZS1wcmUtaW5pdGlhbGl6ZScsIGZ1bmN0aW9uKCBlLCBvcHRzICkge1xyXG4gICAgb25IYXNoQ2hhbmdlKCBvcHRzLCB0cnVlICk7XHJcblxyXG4gICAgb3B0cy5fb25IYXNoQ2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgb25IYXNoQ2hhbmdlKCBvcHRzLCBmYWxzZSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAkKCB3aW5kb3cgKS5vbiggJ2hhc2hjaGFuZ2UnLCBvcHRzLl9vbkhhc2hDaGFuZ2UpO1xyXG59KTtcclxuXHJcbiQoZG9jdW1lbnQpLm9uKCAnY3ljbGUtdXBkYXRlLXZpZXcnLCBmdW5jdGlvbiggZSwgb3B0cywgc2xpZGVPcHRzICkge1xyXG4gICAgaWYgKCBzbGlkZU9wdHMuaGFzaCAmJiAoICcjJyArIHNsaWRlT3B0cy5oYXNoICkgIT0gd2luZG93LmxvY2F0aW9uLmhhc2ggKSB7XHJcbiAgICAgICAgb3B0cy5faGFzaEZlbmNlID0gdHJ1ZTtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHNsaWRlT3B0cy5oYXNoO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbiQoZG9jdW1lbnQpLm9uKCAnY3ljbGUtZGVzdHJveWVkJywgZnVuY3Rpb24oIGUsIG9wdHMpIHtcclxuICAgIGlmICggb3B0cy5fb25IYXNoQ2hhbmdlICkge1xyXG4gICAgICAgICQoIHdpbmRvdyApLm9mZiggJ2hhc2hjaGFuZ2UnLCBvcHRzLl9vbkhhc2hDaGFuZ2UgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBvbkhhc2hDaGFuZ2UoIG9wdHMsIHNldFN0YXJ0aW5nU2xpZGUgKSB7XHJcbiAgICB2YXIgaGFzaDtcclxuICAgIGlmICggb3B0cy5faGFzaEZlbmNlICkge1xyXG4gICAgICAgIG9wdHMuX2hhc2hGZW5jZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKTtcclxuXHJcbiAgICBvcHRzLnNsaWRlcy5lYWNoKGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICBpZiAoICQodGhpcykuZGF0YSggJ2N5Y2xlLWhhc2gnICkgPT0gaGFzaCApIHtcclxuICAgICAgICAgICAgaWYgKCBzZXRTdGFydGluZ1NsaWRlID09PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgb3B0cy5zdGFydGluZ1NsaWRlID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBmd2QgPSBvcHRzLmN1cnJTbGlkZSA8IGk7XHJcbiAgICAgICAgICAgICAgICBvcHRzLm5leHRTbGlkZSA9IGk7XHJcbiAgICAgICAgICAgICAgICBvcHRzLkFQSS5wcmVwYXJlVHgoIHRydWUsIGZ3ZCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxufSkoalF1ZXJ5KTtcclxuXHJcbi8qISBsb2FkZXIgcGx1Z2luIGZvciBDeWNsZTI7ICB2ZXJzaW9uOiAyMDEzMTEyMSAqL1xyXG4oZnVuY3Rpb24oJCkge1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbiQuZXh0ZW5kKCQuZm4uY3ljbGUuZGVmYXVsdHMsIHtcclxuICAgIGxvYWRlcjogZmFsc2VcclxufSk7XHJcblxyXG4kKGRvY3VtZW50KS5vbiggJ2N5Y2xlLWJvb3RzdHJhcCcsIGZ1bmN0aW9uKCBlLCBvcHRzICkge1xyXG4gICAgdmFyIGFkZEZuO1xyXG5cclxuICAgIGlmICggIW9wdHMubG9hZGVyIClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgLy8gb3ZlcnJpZGUgQVBJLmFkZCBmb3IgdGhpcyBzbGlkZXNob3dcclxuICAgIGFkZEZuID0gb3B0cy5BUEkuYWRkO1xyXG4gICAgb3B0cy5BUEkuYWRkID0gYWRkO1xyXG5cclxuICAgIGZ1bmN0aW9uIGFkZCggc2xpZGVzLCBwcmVwZW5kICkge1xyXG4gICAgICAgIHZhciBzbGlkZUFyciA9IFtdO1xyXG4gICAgICAgIGlmICggJC50eXBlKCBzbGlkZXMgKSA9PSAnc3RyaW5nJyApXHJcbiAgICAgICAgICAgIHNsaWRlcyA9ICQudHJpbSggc2xpZGVzICk7XHJcbiAgICAgICAgZWxzZSBpZiAoICQudHlwZSggc2xpZGVzKSA9PT0gJ2FycmF5JyApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSsrIClcclxuICAgICAgICAgICAgICAgIHNsaWRlc1tpXSA9ICQoc2xpZGVzW2ldKVswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNsaWRlcyA9ICQoIHNsaWRlcyApO1xyXG4gICAgICAgIHZhciBzbGlkZUNvdW50ID0gc2xpZGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKCAhIHNsaWRlQ291bnQgKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHNsaWRlcy5jc3MoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKS5hcHBlbmRUbygnYm9keScpLmVhY2goZnVuY3Rpb24oaSkgeyAvLyBhcHBlbmRUbyBmaXhlcyAjNTZcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICAgICAgdmFyIHNsaWRlID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIGltYWdlcyA9IHNsaWRlLmlzKCdpbWcnKSA/IHNsaWRlIDogc2xpZGUuZmluZCgnaW1nJyk7XHJcbiAgICAgICAgICAgIHNsaWRlLmRhdGEoJ2luZGV4JywgaSk7XHJcbiAgICAgICAgICAgIC8vIGFsbG93IHNvbWUgaW1hZ2VzIHRvIGJlIG1hcmtlZCBhcyB1bmltcG9ydGFudCAoYW5kIGZpbHRlciBvdXQgaW1hZ2VzIHcvbyBzcmMgdmFsdWUpXHJcbiAgICAgICAgICAgIGltYWdlcyA9IGltYWdlcy5maWx0ZXIoJzpub3QoLmN5Y2xlLWxvYWRlci1pZ25vcmUpJykuZmlsdGVyKCc6bm90KFtzcmM9XCJcIl0pJyk7XHJcbiAgICAgICAgICAgIGlmICggISBpbWFnZXMubGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgLS1zbGlkZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgc2xpZGVBcnIucHVzaCggc2xpZGUgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY291bnQgPSBpbWFnZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpbWFnZXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFkZCBpbWFnZXMgdGhhdCBhcmUgYWxyZWFkeSBsb2FkZWRcclxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5jb21wbGV0ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZUxvYWRlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5sb2FkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUxvYWRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggLS1jb3VudCA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB0aGlzIHNsaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLkFQSS5sb2coJ3NsaWRlIHNraXBwZWQ7IGltZyBub3QgbG9hZGVkOicsIHRoaXMuc3JjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggLS1zbGlkZUNvdW50ID09PSAwICYmIG9wdHMubG9hZGVyID09ICd3YWl0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZuLmFwcGx5KCBvcHRzLkFQSSwgWyBzbGlkZUFyciwgcHJlcGVuZCBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbWFnZUxvYWRlZCgpIHtcclxuICAgICAgICAgICAgICAgIGlmICggLS1jb3VudCA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAtLXNsaWRlQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkU2xpZGUoIHNsaWRlICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCBzbGlkZUNvdW50IClcclxuICAgICAgICAgICAgb3B0cy5jb250YWluZXIuYWRkQ2xhc3MoJ2N5Y2xlLWxvYWRpbmcnKTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkU2xpZGUoIHNsaWRlICkge1xyXG4gICAgICAgICAgICB2YXIgY3VycjtcclxuICAgICAgICAgICAgaWYgKCBvcHRzLmxvYWRlciA9PSAnd2FpdCcgKSB7XHJcbiAgICAgICAgICAgICAgICBzbGlkZUFyci5wdXNoKCBzbGlkZSApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBzbGlkZUNvdW50ID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICM1OTsgc29ydCBzbGlkZXMgaW50byBvcmlnaW5hbCBtYXJrdXAgb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICBzbGlkZUFyci5zb3J0KCBzb3J0ZXIgKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRGbi5hcHBseSggb3B0cy5BUEksIFsgc2xpZGVBcnIsIHByZXBlbmQgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLnJlbW92ZUNsYXNzKCdjeWNsZS1sb2FkaW5nJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyID0gJChvcHRzLnNsaWRlc1tvcHRzLmN1cnJTbGlkZV0pO1xyXG4gICAgICAgICAgICAgICAgYWRkRm4uYXBwbHkoIG9wdHMuQVBJLCBbIHNsaWRlLCBwcmVwZW5kIF0gKTtcclxuICAgICAgICAgICAgICAgIGN1cnIuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgb3B0cy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ2N5Y2xlLWxvYWRpbmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuZGF0YSgnaW5kZXgnKSAtIGIuZGF0YSgnaW5kZXgnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxufSkoalF1ZXJ5KTtcclxuXHJcbi8qISBwYWdlciBwbHVnaW4gZm9yIEN5Y2xlMjsgIHZlcnNpb246IDIwMTQwNDE1ICovXHJcbihmdW5jdGlvbigkKSB7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuJC5leHRlbmQoJC5mbi5jeWNsZS5kZWZhdWx0cywge1xyXG4gICAgcGFnZXI6ICAgICAgICAgICAgJz4gLmN5Y2xlLXBhZ2VyJyxcclxuICAgIHBhZ2VyQWN0aXZlQ2xhc3M6ICdjeWNsZS1wYWdlci1hY3RpdmUnLFxyXG4gICAgcGFnZXJFdmVudDogICAgICAgJ2NsaWNrLmN5Y2xlJyxcclxuICAgIHBhZ2VyRXZlbnRCdWJibGU6IHVuZGVmaW5lZCxcclxuICAgIHBhZ2VyVGVtcGxhdGU6ICAgICc8c3Bhbj4mYnVsbDs8L3NwYW4+J1xyXG59KTtcclxuXHJcbiQoZG9jdW1lbnQpLm9uKCAnY3ljbGUtYm9vdHN0cmFwJywgZnVuY3Rpb24oIGUsIG9wdHMsIEFQSSApIHtcclxuICAgIC8vIGFkZCBtZXRob2QgdG8gQVBJXHJcbiAgICBBUEkuYnVpbGRQYWdlckxpbmsgPSBidWlsZFBhZ2VyTGluaztcclxufSk7XHJcblxyXG4kKGRvY3VtZW50KS5vbiggJ2N5Y2xlLXNsaWRlLWFkZGVkJywgZnVuY3Rpb24oIGUsIG9wdHMsIHNsaWRlT3B0cywgc2xpZGVBZGRlZCApIHtcclxuICAgIGlmICggb3B0cy5wYWdlciApIHtcclxuICAgICAgICBvcHRzLkFQSS5idWlsZFBhZ2VyTGluayAoIG9wdHMsIHNsaWRlT3B0cywgc2xpZGVBZGRlZCApO1xyXG4gICAgICAgIG9wdHMuQVBJLnBhZ2UgPSBwYWdlO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbiQoZG9jdW1lbnQpLm9uKCAnY3ljbGUtc2xpZGUtcmVtb3ZlZCcsIGZ1bmN0aW9uKCBlLCBvcHRzLCBpbmRleCwgc2xpZGVSZW1vdmVkICkge1xyXG4gICAgaWYgKCBvcHRzLnBhZ2VyICkge1xyXG4gICAgICAgIHZhciBwYWdlcnMgPSBvcHRzLkFQSS5nZXRDb21wb25lbnQoICdwYWdlcicgKTtcclxuICAgICAgICBwYWdlcnMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHBhZ2VyID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgJCggcGFnZXIuY2hpbGRyZW4oKVtpbmRleF0gKS5yZW1vdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4kKGRvY3VtZW50KS5vbiggJ2N5Y2xlLXVwZGF0ZS12aWV3JywgZnVuY3Rpb24oIGUsIG9wdHMsIHNsaWRlT3B0cyApIHtcclxuICAgIHZhciBwYWdlcnM7XHJcblxyXG4gICAgaWYgKCBvcHRzLnBhZ2VyICkge1xyXG4gICAgICAgIHBhZ2VycyA9IG9wdHMuQVBJLmdldENvbXBvbmVudCggJ3BhZ2VyJyApO1xyXG4gICAgICAgIHBhZ2Vycy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICQodGhpcykuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyggb3B0cy5wYWdlckFjdGl2ZUNsYXNzIClcclxuICAgICAgICAgICAgLmVxKCBvcHRzLmN1cnJTbGlkZSApLmFkZENsYXNzKCBvcHRzLnBhZ2VyQWN0aXZlQ2xhc3MgKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4kKGRvY3VtZW50KS5vbiggJ2N5Y2xlLWRlc3Ryb3llZCcsIGZ1bmN0aW9uKCBlLCBvcHRzICkge1xyXG4gICAgdmFyIHBhZ2VyID0gb3B0cy5BUEkuZ2V0Q29tcG9uZW50KCAncGFnZXInICk7XHJcblxyXG4gICAgaWYgKCBwYWdlciApIHtcclxuICAgICAgICBwYWdlci5jaGlsZHJlbigpLm9mZiggb3B0cy5wYWdlckV2ZW50ICk7IC8vICMyMDJcclxuICAgICAgICBpZiAoIG9wdHMucGFnZXJUZW1wbGF0ZSApXHJcbiAgICAgICAgICAgIHBhZ2VyLmVtcHR5KCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gYnVpbGRQYWdlckxpbmsoIG9wdHMsIHNsaWRlT3B0cywgc2xpZGUgKSB7XHJcbiAgICB2YXIgcGFnZXJMaW5rO1xyXG4gICAgdmFyIHBhZ2VycyA9IG9wdHMuQVBJLmdldENvbXBvbmVudCggJ3BhZ2VyJyApO1xyXG4gICAgcGFnZXJzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhZ2VyID0gJCh0aGlzKTtcclxuICAgICAgICBpZiAoIHNsaWRlT3B0cy5wYWdlclRlbXBsYXRlICkge1xyXG4gICAgICAgICAgICB2YXIgbWFya3VwID0gb3B0cy5BUEkudG1wbCggc2xpZGVPcHRzLnBhZ2VyVGVtcGxhdGUsIHNsaWRlT3B0cywgb3B0cywgc2xpZGVbMF0gKTtcclxuICAgICAgICAgICAgcGFnZXJMaW5rID0gJCggbWFya3VwICkuYXBwZW5kVG8oIHBhZ2VyICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYWdlckxpbmsgPSBwYWdlci5jaGlsZHJlbigpLmVxKCBvcHRzLnNsaWRlQ291bnQgLSAxICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhZ2VyTGluay5vbiggb3B0cy5wYWdlckV2ZW50LCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGlmICggISBvcHRzLnBhZ2VyRXZlbnRCdWJibGUgKVxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBvcHRzLkFQSS5wYWdlKCBwYWdlciwgZS5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWdlKCBwYWdlciwgdGFyZ2V0ICkge1xyXG4gICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cclxuICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCk7XHJcbiAgICBpZiAoIG9wdHMuYnVzeSAmJiAhIG9wdHMubWFudWFsVHJ1bXAgKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICB2YXIgaW5kZXggPSBwYWdlci5jaGlsZHJlbigpLmluZGV4KCB0YXJnZXQgKTtcclxuICAgIHZhciBuZXh0U2xpZGUgPSBpbmRleDtcclxuICAgIHZhciBmd2QgPSBvcHRzLmN1cnJTbGlkZSA8IG5leHRTbGlkZTtcclxuICAgIGlmIChvcHRzLmN1cnJTbGlkZSA9PSBuZXh0U2xpZGUpIHtcclxuICAgICAgICByZXR1cm47IC8vIG5vIG9wLCBjbGlja2VkIHBhZ2VyIGZvciB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBzbGlkZVxyXG4gICAgfVxyXG4gICAgb3B0cy5uZXh0U2xpZGUgPSBuZXh0U2xpZGU7XHJcbiAgICBvcHRzLl90ZW1wRnggPSBvcHRzLnBhZ2VyRng7XHJcbiAgICBvcHRzLkFQSS5wcmVwYXJlVHgoIHRydWUsIGZ3ZCApO1xyXG4gICAgb3B0cy5BUEkudHJpZ2dlcignY3ljbGUtcGFnZXItYWN0aXZhdGVkJywgW29wdHMsIHBhZ2VyLCB0YXJnZXQgXSk7XHJcbn1cclxuXHJcbn0pKGpRdWVyeSk7XHJcblxyXG4vKiEgcHJldm5leHQgcGx1Z2luIGZvciBDeWNsZTI7ICB2ZXJzaW9uOiAyMDE0MDQwOCAqL1xyXG4oZnVuY3Rpb24oJCkge1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbiQuZXh0ZW5kKCQuZm4uY3ljbGUuZGVmYXVsdHMsIHtcclxuICAgIG5leHQ6ICAgICAgICAgICAnPiAuY3ljbGUtbmV4dCcsXHJcbiAgICBuZXh0RXZlbnQ6ICAgICAgJ2NsaWNrLmN5Y2xlJyxcclxuICAgIGRpc2FibGVkQ2xhc3M6ICAnZGlzYWJsZWQnLFxyXG4gICAgcHJldjogICAgICAgICAgICc+IC5jeWNsZS1wcmV2JyxcclxuICAgIHByZXZFdmVudDogICAgICAnY2xpY2suY3ljbGUnLFxyXG4gICAgc3dpcGU6ICAgICAgICAgIGZhbHNlXHJcbn0pO1xyXG5cclxuJChkb2N1bWVudCkub24oICdjeWNsZS1pbml0aWFsaXplZCcsIGZ1bmN0aW9uKCBlLCBvcHRzICkge1xyXG4gICAgb3B0cy5BUEkuZ2V0Q29tcG9uZW50KCAnbmV4dCcgKS5vbiggb3B0cy5uZXh0RXZlbnQsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgb3B0cy5BUEkubmV4dCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgb3B0cy5BUEkuZ2V0Q29tcG9uZW50KCAncHJldicgKS5vbiggb3B0cy5wcmV2RXZlbnQsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgb3B0cy5BUEkucHJldigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCBvcHRzLnN3aXBlICkge1xyXG4gICAgICAgIHZhciBuZXh0RXZlbnQgPSBvcHRzLnN3aXBlVmVydCA/ICdzd2lwZVVwLmN5Y2xlJyA6ICdzd2lwZUxlZnQuY3ljbGUgc3dpcGVsZWZ0LmN5Y2xlJztcclxuICAgICAgICB2YXIgcHJldkV2ZW50ID0gb3B0cy5zd2lwZVZlcnQgPyAnc3dpcGVEb3duLmN5Y2xlJyA6ICdzd2lwZVJpZ2h0LmN5Y2xlIHN3aXBlcmlnaHQuY3ljbGUnO1xyXG4gICAgICAgIG9wdHMuY29udGFpbmVyLm9uKCBuZXh0RXZlbnQsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgb3B0cy5fdGVtcEZ4ID0gb3B0cy5zd2lwZUZ4O1xyXG4gICAgICAgICAgICBvcHRzLkFQSS5uZXh0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb3B0cy5jb250YWluZXIub24oIHByZXZFdmVudCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIG9wdHMuX3RlbXBGeCA9IG9wdHMuc3dpcGVGeDtcclxuICAgICAgICAgICAgb3B0cy5BUEkucHJldigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbiQoZG9jdW1lbnQpLm9uKCAnY3ljbGUtdXBkYXRlLXZpZXcnLCBmdW5jdGlvbiggZSwgb3B0cywgc2xpZGVPcHRzLCBjdXJyU2xpZGUgKSB7XHJcbiAgICBpZiAoIG9wdHMuYWxsb3dXcmFwIClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgdmFyIGNscyA9IG9wdHMuZGlzYWJsZWRDbGFzcztcclxuICAgIHZhciBuZXh0ID0gb3B0cy5BUEkuZ2V0Q29tcG9uZW50KCAnbmV4dCcgKTtcclxuICAgIHZhciBwcmV2ID0gb3B0cy5BUEkuZ2V0Q29tcG9uZW50KCAncHJldicgKTtcclxuICAgIHZhciBwcmV2Qm91bmRyeSA9IG9wdHMuX3ByZXZCb3VuZHJ5IHx8IDA7XHJcbiAgICB2YXIgbmV4dEJvdW5kcnkgPSAob3B0cy5fbmV4dEJvdW5kcnkgIT09IHVuZGVmaW5lZCk/b3B0cy5fbmV4dEJvdW5kcnk6b3B0cy5zbGlkZUNvdW50IC0gMTtcclxuXHJcbiAgICBpZiAoIG9wdHMuY3VyclNsaWRlID09IG5leHRCb3VuZHJ5IClcclxuICAgICAgICBuZXh0LmFkZENsYXNzKCBjbHMgKS5wcm9wKCAnZGlzYWJsZWQnLCB0cnVlICk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgbmV4dC5yZW1vdmVDbGFzcyggY2xzICkucHJvcCggJ2Rpc2FibGVkJywgZmFsc2UgKTtcclxuXHJcbiAgICBpZiAoIG9wdHMuY3VyclNsaWRlID09PSBwcmV2Qm91bmRyeSApXHJcbiAgICAgICAgcHJldi5hZGRDbGFzcyggY2xzICkucHJvcCggJ2Rpc2FibGVkJywgdHJ1ZSApO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHByZXYucmVtb3ZlQ2xhc3MoIGNscyApLnByb3AoICdkaXNhYmxlZCcsIGZhbHNlICk7XHJcbn0pO1xyXG5cclxuXHJcbiQoZG9jdW1lbnQpLm9uKCAnY3ljbGUtZGVzdHJveWVkJywgZnVuY3Rpb24oIGUsIG9wdHMgKSB7XHJcbiAgICBvcHRzLkFQSS5nZXRDb21wb25lbnQoICdwcmV2JyApLm9mZiggb3B0cy5uZXh0RXZlbnQgKTtcclxuICAgIG9wdHMuQVBJLmdldENvbXBvbmVudCggJ25leHQnICkub2ZmKCBvcHRzLnByZXZFdmVudCApO1xyXG4gICAgb3B0cy5jb250YWluZXIub2ZmKCAnc3dpcGVsZWZ0LmN5Y2xlIHN3aXBlcmlnaHQuY3ljbGUgc3dpcGVMZWZ0LmN5Y2xlIHN3aXBlUmlnaHQuY3ljbGUgc3dpcGVVcC5jeWNsZSBzd2lwZURvd24uY3ljbGUnICk7XHJcbn0pO1xyXG5cclxufSkoalF1ZXJ5KTtcclxuXHJcbi8qISBwcm9ncmVzc2l2ZSBsb2FkZXIgcGx1Z2luIGZvciBDeWNsZTI7ICB2ZXJzaW9uOiAyMDEzMDMxNSAqL1xyXG4oZnVuY3Rpb24oJCkge1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbiQuZXh0ZW5kKCQuZm4uY3ljbGUuZGVmYXVsdHMsIHtcclxuICAgIHByb2dyZXNzaXZlOiBmYWxzZVxyXG59KTtcclxuXHJcbiQoZG9jdW1lbnQpLm9uKCAnY3ljbGUtcHJlLWluaXRpYWxpemUnLCBmdW5jdGlvbiggZSwgb3B0cyApIHtcclxuICAgIGlmICggIW9wdHMucHJvZ3Jlc3NpdmUgKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICB2YXIgQVBJID0gb3B0cy5BUEk7XHJcbiAgICB2YXIgbmV4dEZuID0gQVBJLm5leHQ7XHJcbiAgICB2YXIgcHJldkZuID0gQVBJLnByZXY7XHJcbiAgICB2YXIgcHJlcGFyZVR4Rm4gPSBBUEkucHJlcGFyZVR4O1xyXG4gICAgdmFyIHR5cGUgPSAkLnR5cGUoIG9wdHMucHJvZ3Jlc3NpdmUgKTtcclxuICAgIHZhciBzbGlkZXMsIHNjcmlwdEVsO1xyXG5cclxuICAgIGlmICggdHlwZSA9PSAnYXJyYXknICkge1xyXG4gICAgICAgIHNsaWRlcyA9IG9wdHMucHJvZ3Jlc3NpdmU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgkLmlzRnVuY3Rpb24oIG9wdHMucHJvZ3Jlc3NpdmUgKSApIHtcclxuICAgICAgICBzbGlkZXMgPSBvcHRzLnByb2dyZXNzaXZlKCBvcHRzICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggdHlwZSA9PSAnc3RyaW5nJyApIHtcclxuICAgICAgICBzY3JpcHRFbCA9ICQoIG9wdHMucHJvZ3Jlc3NpdmUgKTtcclxuICAgICAgICBzbGlkZXMgPSAkLnRyaW0oIHNjcmlwdEVsLmh0bWwoKSApO1xyXG4gICAgICAgIGlmICggIXNsaWRlcyApXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyBpcyBpdCBqc29uIGFycmF5P1xyXG4gICAgICAgIGlmICggL14oXFxbKS8udGVzdCggc2xpZGVzICkgKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzbGlkZXMgPSAkLnBhcnNlSlNPTiggc2xpZGVzICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBBUEkubG9nKCAnZXJyb3IgcGFyc2luZyBwcm9ncmVzc2l2ZSBzbGlkZXMnLCBlcnIgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcGxhaW4gdGV4dCwgc3BsaXQgb24gZGVsaW1ldGVyXHJcbiAgICAgICAgICAgIHNsaWRlcyA9IHNsaWRlcy5zcGxpdCggbmV3IFJlZ0V4cCggc2NyaXB0RWwuZGF0YSgnY3ljbGUtc3BsaXQnKSB8fCAnXFxuJykgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vICM5NTsgbG9vayBmb3IgZW1wdHkgc2xpZGVcclxuICAgICAgICAgICAgaWYgKCAhIHNsaWRlc1sgc2xpZGVzLmxlbmd0aCAtIDEgXSApXHJcbiAgICAgICAgICAgICAgICBzbGlkZXMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgaWYgKCBwcmVwYXJlVHhGbiApIHtcclxuICAgICAgICBBUEkucHJlcGFyZVR4ID0gZnVuY3Rpb24oIG1hbnVhbCwgZndkICkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXgsIHNsaWRlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtYW51YWwgfHwgc2xpZGVzLmxlbmd0aCA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgIHByZXBhcmVUeEZuLmFwcGx5KCBvcHRzLkFQSSwgWyBtYW51YWwsIGZ3ZCBdICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggZndkICYmIG9wdHMuY3VyclNsaWRlID09ICggb3B0cy5zbGlkZUNvdW50LTEpICkge1xyXG4gICAgICAgICAgICAgICAgc2xpZGUgPSBzbGlkZXNbIDAgXTtcclxuICAgICAgICAgICAgICAgIHNsaWRlcyA9IHNsaWRlcy5zbGljZSggMSApO1xyXG4gICAgICAgICAgICAgICAgb3B0cy5jb250YWluZXIub25lKCdjeWNsZS1zbGlkZS1hZGRlZCcsIGZ1bmN0aW9uKGUsIG9wdHMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5BUEkuYWR2YW5jZVNsaWRlKCAxICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSw1MCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG9wdHMuQVBJLmFkZCggc2xpZGUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICggIWZ3ZCAmJiBvcHRzLmN1cnJTbGlkZSA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gc2xpZGVzLmxlbmd0aC0xO1xyXG4gICAgICAgICAgICAgICAgc2xpZGUgPSBzbGlkZXNbIGluZGV4IF07XHJcbiAgICAgICAgICAgICAgICBzbGlkZXMgPSBzbGlkZXMuc2xpY2UoIDAsIGluZGV4ICk7XHJcbiAgICAgICAgICAgICAgICBvcHRzLmNvbnRhaW5lci5vbmUoJ2N5Y2xlLXNsaWRlLWFkZGVkJywgZnVuY3Rpb24oZSwgb3B0cyApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmN1cnJTbGlkZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuQVBJLmFkdmFuY2VTbGlkZSggLTEgKTtcclxuICAgICAgICAgICAgICAgICAgICB9LDUwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgb3B0cy5BUEkuYWRkKCBzbGlkZSwgdHJ1ZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJlcGFyZVR4Rm4uYXBwbHkoIG9wdHMuQVBJLCBbIG1hbnVhbCwgZndkIF0gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCBuZXh0Rm4gKSB7XHJcbiAgICAgICAgQVBJLm5leHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHMoKTtcclxuICAgICAgICAgICAgaWYgKCBzbGlkZXMubGVuZ3RoICYmIG9wdHMuY3VyclNsaWRlID09ICggb3B0cy5zbGlkZUNvdW50IC0gMSApICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsaWRlID0gc2xpZGVzWyAwIF07XHJcbiAgICAgICAgICAgICAgICBzbGlkZXMgPSBzbGlkZXMuc2xpY2UoIDEgKTtcclxuICAgICAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLm9uZSgnY3ljbGUtc2xpZGUtYWRkZWQnLCBmdW5jdGlvbihlLCBvcHRzICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRGbi5hcHBseSggb3B0cy5BUEkgKTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnY3ljbGUtbG9hZGluZycpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBvcHRzLmNvbnRhaW5lci5hZGRDbGFzcygnY3ljbGUtbG9hZGluZycpO1xyXG4gICAgICAgICAgICAgICAgb3B0cy5BUEkuYWRkKCBzbGlkZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV4dEZuLmFwcGx5KCBvcHRzLkFQSSApOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICggcHJldkZuICkge1xyXG4gICAgICAgIEFQSS5wcmV2ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCk7XHJcbiAgICAgICAgICAgIGlmICggc2xpZGVzLmxlbmd0aCAmJiBvcHRzLmN1cnJTbGlkZSA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHNsaWRlcy5sZW5ndGgtMTtcclxuICAgICAgICAgICAgICAgIHZhciBzbGlkZSA9IHNsaWRlc1sgaW5kZXggXTtcclxuICAgICAgICAgICAgICAgIHNsaWRlcyA9IHNsaWRlcy5zbGljZSggMCwgaW5kZXggKTtcclxuICAgICAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLm9uZSgnY3ljbGUtc2xpZGUtYWRkZWQnLCBmdW5jdGlvbihlLCBvcHRzICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMuY3VyclNsaWRlID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLkFQSS5hZHZhbmNlU2xpZGUoIC0xICk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ2N5Y2xlLWxvYWRpbmcnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgb3B0cy5jb250YWluZXIuYWRkQ2xhc3MoJ2N5Y2xlLWxvYWRpbmcnKTtcclxuICAgICAgICAgICAgICAgIG9wdHMuQVBJLmFkZCggc2xpZGUsIHRydWUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByZXZGbi5hcHBseSggb3B0cy5BUEkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn0pO1xyXG5cclxufSkoalF1ZXJ5KTtcclxuXHJcbi8qISB0bXBsIHBsdWdpbiBmb3IgQ3ljbGUyOyAgdmVyc2lvbjogMjAxMjEyMjcgKi9cclxuKGZ1bmN0aW9uKCQpIHtcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4kLmV4dGVuZCgkLmZuLmN5Y2xlLmRlZmF1bHRzLCB7XHJcbiAgICB0bXBsUmVnZXg6ICd7eygoLik/Lio/KX19J1xyXG59KTtcclxuXHJcbiQuZXh0ZW5kKCQuZm4uY3ljbGUuQVBJLCB7XHJcbiAgICB0bXBsOiBmdW5jdGlvbiggc3RyLCBvcHRzIC8qLCAuLi4gKi8pIHtcclxuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCBvcHRzLnRtcGxSZWdleCB8fCAkLmZuLmN5Y2xlLmRlZmF1bHRzLnRtcGxSZWdleCwgJ2cnICk7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSAkLm1ha2VBcnJheSggYXJndW1lbnRzICk7XHJcbiAgICAgICAgYXJncy5zaGlmdCgpO1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZWdleCwgZnVuY3Rpb24oXywgc3RyKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBqLCBvYmosIHByb3AsIG5hbWVzID0gc3RyLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIGZvciAoaT0wOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gYXJnc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmICggISBvYmogKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaj0wOyBqIDwgbmFtZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gcHJvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3BbIG5hbWVzW2pdIF0gfHwgc3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IG9ialtzdHJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24ocHJvcCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3AuYXBwbHkob2JqLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wICE9PSB1bmRlZmluZWQgJiYgcHJvcCAhPT0gbnVsbCAmJiBwcm9wICE9IHN0cilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTsgICAgXHJcblxyXG59KShqUXVlcnkpO1xyXG4iLCIvKiEgc3dpcGUgcGx1Z2luIGZvciBDeWNsZTI7ICB2ZXJzaW9uOiAyMDEyMTEyMCAqL1xyXG4oZnVuY3Rpb24oJCkge1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIHRoaXMgc2NyaXB0IGFkZHMgc3VwcG9ydCBmb3IgdG91Y2ggZXZlbnRzLiAgdGhlIGxvZ2ljIGlzIGxpZnRlZCBmcm9tIGpRdWVyeSBNb2JpbGUuXHJcbi8vIGlmIHlvdSBoYXZlIGpRdWVyeSBNb2JpbGUgaW5zdGFsbGVkLCB5b3UgZG8gTk9UIG5lZWQgdGhpcyBzY3JpcHRcclxuXHJcbnZhciBzdXBwb3J0VG91Y2ggPSAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQ7XHJcblxyXG4kLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUgfHwge1xyXG4gICAgc2Nyb2xsU3VwcmVzc2lvblRocmVzaG9sZDogMTAsICAgLy8gTW9yZSB0aGFuIHRoaXMgaG9yaXpvbnRhbCBkaXNwbGFjZW1lbnQsIGFuZCB3ZSB3aWxsIHN1cHByZXNzIHNjcm9sbGluZy5cclxuICAgIGR1cmF0aW9uVGhyZXNob2xkOiAxMDAwLCAgICAgICAgIC8vIE1vcmUgdGltZSB0aGFuIHRoaXMsIGFuZCBpdCBpc24ndCBhIHN3aXBlLlxyXG4gICAgaG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkOiAzMCwgLy8gU3dpcGUgaG9yaXpvbnRhbCBkaXNwbGFjZW1lbnQgbXVzdCBiZSBtb3JlIHRoYW4gdGhpcy5cclxuICAgIHZlcnRpY2FsRGlzdGFuY2VUaHJlc2hvbGQ6IDc1LCAgIC8vIFN3aXBlIHZlcnRpY2FsIGRpc3BsYWNlbWVudCBtdXN0IGJlIGxlc3MgdGhhbiB0aGlzLlxyXG5cclxuICAgIHNldHVwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgJHRoaXMgPSAkKCB0aGlzICk7XHJcblxyXG4gICAgICAgICR0aGlzLmJpbmQoICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1sgMCBdIDogZXZlbnQ7XHJcbiAgICAgICAgICAgIHZhciBzdG9wLCBzdGFydCA9IHtcclxuICAgICAgICAgICAgICAgIHRpbWU6ICggbmV3IERhdGUoKSApLmdldFRpbWUoKSxcclxuICAgICAgICAgICAgICAgIGNvb3JkczogWyBkYXRhLnBhZ2VYLCBkYXRhLnBhZ2VZIF0sXHJcbiAgICAgICAgICAgICAgICBvcmlnaW46ICQoIGV2ZW50LnRhcmdldCApXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtb3ZlSGFuZGxlciggZXZlbnQgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFzdGFydCApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzID8gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWyAwIF0gOiBldmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICBzdG9wID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6ICggbmV3IERhdGUoKSApLmdldFRpbWUoKSxcclxuICAgICAgICAgICAgICAgICAgICBjb29yZHM6IFsgZGF0YS5wYWdlWCwgZGF0YS5wYWdlWSBdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDAgXSAtIHN0b3AuY29vcmRzWyAwIF0gKSA+ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5zY3JvbGxTdXByZXNzaW9uVGhyZXNob2xkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICR0aGlzLmJpbmQoICd0b3VjaG1vdmUnLCBtb3ZlSGFuZGxlciApXHJcbiAgICAgICAgICAgICAgICAub25lKCAndG91Y2hlbmQnLCBmdW5jdGlvbiggZXZlbnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudW5iaW5kKCAndG91Y2htb3ZlJywgbW92ZUhhbmRsZXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFydCAmJiBzdG9wICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0b3AudGltZSAtIHN0YXJ0LnRpbWUgPCAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZHVyYXRpb25UaHJlc2hvbGQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyggc3RhcnQuY29vcmRzWyAwIF0gLSBzdG9wLmNvb3Jkc1sgMCBdICkgPiAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuaG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMSBdIC0gc3RvcC5jb29yZHNbIDEgXSApIDwgJC5ldmVudC5zcGVjaWFsLnN3aXBlLnZlcnRpY2FsRGlzdGFuY2VUaHJlc2hvbGQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQub3JpZ2luLnRyaWdnZXIoIFwic3dpcGVcIiApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyaWdnZXIoIHN0YXJ0LmNvb3Jkc1swXSA+IHN0b3AuY29vcmRzWyAwIF0gPyBcInN3aXBlbGVmdFwiIDogXCJzd2lwZXJpZ2h0XCIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0b3AgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuXHJcbiQuZXZlbnQuc3BlY2lhbC5zd2lwZWxlZnQgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGVsZWZ0IHx8IHtcclxuICAgIHNldHVwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAkKCB0aGlzICkuYmluZCggJ3N3aXBlJywgJC5ub29wICk7XHJcbiAgICB9XHJcbn07XHJcbiQuZXZlbnQuc3BlY2lhbC5zd2lwZXJpZ2h0ID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlcmlnaHQgfHwgJC5ldmVudC5zcGVjaWFsLnN3aXBlbGVmdDtcclxuXHJcbn0pKGpRdWVyeSk7XHJcbiIsIi8qISBjc3MzIGZsaXAgdHJhbnNpdGlvbiBwbHVnaW4gZm9yIEN5Y2xlMjsgIHZlcnNpb246IDIwMTQwMTI4ICovXHJcbi8qISBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgTGF1YmVlZSAoaHR0cHM6Ly9naXRodWIuY29tL0xhdWJlZWUpICovXHJcbihmdW5jdGlvbigkKSB7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGJhY2tmYWNlLFxyXG4gICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZSxcclxuICAgIHR4ID0gJC5mbi5jeWNsZS50cmFuc2l0aW9ucyxcclxuICAgIHN1cHBvcnRlZCA9IHN0eWxlLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgc3R5bGUuTW96VHJhbnNmb3JtICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgIHN0eWxlLm9UcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgIHN0eWxlLm1zVHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XHJcblxyXG5pZiAoIHN1cHBvcnRlZCAmJiBzdHlsZS5tc1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgc3R5bGUubXNUcmFuc2Zvcm0gPSAncm90YXRlWSgwZGVnKSc7XHJcbiAgICBpZiAoICEgc3R5bGUubXNUcmFuc2Zvcm0gKVxyXG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG59XHJcblxyXG5pZiAoIHN1cHBvcnRlZCApIHtcclxuICAgIHR4LmZsaXBIb3J6ID0gZ2V0VHJhbnNpdGlvbiggZ2V0Um90YXRlKCdZJykgKTtcclxuICAgIHR4LmZsaXBWZXJ0ID0gZ2V0VHJhbnNpdGlvbiggZ2V0Um90YXRlKCdYJykgKTtcclxuICAgIGJhY2tmYWNlID0ge1xyXG4gICAgICAgICctd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHknOiAnaGlkZGVuJyxcclxuICAgICAgICAnLW1vei1iYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbicsXHJcbiAgICAgICAgJy1vLWJhY2tmYWNlLXZpc2liaWxpdHknOiAnaGlkZGVuJyxcclxuICAgICAgICAnYmFja2ZhY2UtdmlzaWJpbGl0eSc6ICdoaWRkZW4nXHJcbiAgICB9O1xyXG59XHJcbmVsc2Uge1xyXG4gICAgLy8gZmFsbGJhY2sgdG8gc2Nyb2xsIHR4IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdHJhbnNmb3Jtc1xyXG4gICAgdHguZmxpcEhvcnogPSB0eC5zY3JvbGxIb3J6O1xyXG4gICAgdHguZmxpcFZlcnQgPSB0eC5zY3JvbGxWZXJ0IHx8IHR4LnNjcm9sbEhvcno7XHJcbn1cclxuXHJcbiAgICBcclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbiggcm90YXRlRm4gKSB7XHJcbiAgICAvLyByZXR1cm4gQzIgdHJhbnNpdGlvbiBvYmplY3RcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJlSW5pdDogZnVuY3Rpb24oIG9wdHMgKSB7XHJcbiAgICAgICAgICAgIG9wdHMuc2xpZGVzLmNzcyggYmFja2ZhY2UgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zaXRpb246IGZ1bmN0aW9uKCBzbGlkZU9wdHMsIGN1cnJFbCwgbmV4dEVsLCBmd2QsIGNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICB2YXIgb3B0cyA9IHNsaWRlT3B0cyxcclxuICAgICAgICAgICAgICAgIGN1cnIgPSAkKGN1cnJFbCksIFxyXG4gICAgICAgICAgICAgICAgbmV4dCA9ICQobmV4dEVsKSxcclxuICAgICAgICAgICAgICAgIHNwZWVkID0gb3B0cy5zcGVlZCAvIDI7XHJcblxyXG4gICAgICAgICAgICAvLyBjc3MgYmVmb3JlIHRyYW5zaXRpb24gc3RhcnRcclxuICAgICAgICAgICAgcm90YXRlRm4uY2FsbChuZXh0LCAtOTApO1xyXG4gICAgICAgICAgICBuZXh0LmNzcyh7XHJcbiAgICAgICAgICAgICAgICAnZGlzcGxheSc6ICdibG9jaycsXHJcbiAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcclxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzogJy05MHB4JyxcclxuICAgICAgICAgICAgICAgICdvcGFjaXR5JzogMVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGN1cnIuY3NzKCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgJzBweCcpO1xyXG5cclxuICAgICAgICAgICAgY3Vyci5hbmltYXRlKHsgYmFja2dyb3VuZFBvc2l0aW9uOiA5MCB9LCB7XHJcbiAgICAgICAgICAgICAgICBzdGVwOiByb3RhdGVGbixcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBzcGVlZCxcclxuICAgICAgICAgICAgICAgIGVhc2luZzogb3B0cy5lYXNlT3V0IHx8IG9wdHMuZWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsaWRlT3B0cy5BUEkudXBkYXRlVmlldyggZmFsc2UsIHRydWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0LmFuaW1hdGUoeyBiYWNrZ3JvdW5kUG9zaXRpb246IDAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiByb3RhdGVGbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHNwZWVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IG9wdHMuZWFzZUluIHx8IG9wdHMuZWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Um90YXRlKCBkaXIgKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oIGRlZ3JlZXMgKSB7XHJcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cclxuICAgICAgICB2YXIgZWwgPSAkKHRoaXMpO1xyXG4gICAgICAgIGVsLmNzcyh7XHJcbiAgICAgICAgICAgICctd2Via2l0LXRyYW5zZm9ybSc6ICdyb3RhdGUnK2RpcisnKCcrZGVncmVlcysnZGVnKScsXHJcbiAgICAgICAgICAgICctbW96LXRyYW5zZm9ybSc6ICdyb3RhdGUnK2RpcisnKCcrZGVncmVlcysnZGVnKScsIFxyXG4gICAgICAgICAgICAnLW1zLXRyYW5zZm9ybSc6ICdyb3RhdGUnK2RpcisnKCcrZGVncmVlcysnZGVnKScsXHJcbiAgICAgICAgICAgICctby10cmFuc2Zvcm0nOiAncm90YXRlJytkaXIrJygnK2RlZ3JlZXMrJ2RlZyknLFxyXG4gICAgICAgICAgICAndHJhbnNmb3JtJzogJ3JvdGF0ZScrZGlyKycoJytkZWdyZWVzKydkZWcpJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5cclxufSkoalF1ZXJ5KTtcclxuIiwiLyohIGNhcm91c2VsIHRyYW5zaXRpb24gcGx1Z2luIGZvciBDeWNsZTI7ICB2ZXJzaW9uOiAyMDEzMDUyOCAqL1xyXG4oZnVuY3Rpb24oJCkge1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbiQoIGRvY3VtZW50ICkub24oJ2N5Y2xlLWJvb3RzdHJhcCcsIGZ1bmN0aW9uKCBlLCBvcHRzLCBBUEkgKSB7XHJcbiAgICBpZiAoIG9wdHMuZnggIT09ICdjYXJvdXNlbCcgKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICBBUEkuZ2V0U2xpZGVJbmRleCA9IGZ1bmN0aW9uKCBlbCApIHtcclxuICAgICAgICB2YXIgc2xpZGVzID0gdGhpcy5vcHRzKCkuX2Nhcm91c2VsV3JhcC5jaGlsZHJlbigpO1xyXG4gICAgICAgIHZhciBpID0gc2xpZGVzLmluZGV4KCBlbCApO1xyXG4gICAgICAgIHJldHVybiBpICUgc2xpZGVzLmxlbmd0aDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gb3ZlcnJpZGUgZGVmYXVsdCAnbmV4dCcgZnVuY3Rpb25cclxuICAgIEFQSS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gb3B0cy5yZXZlcnNlID8gLTEgOiAxO1xyXG4gICAgICAgIGlmICggb3B0cy5hbGxvd1dyYXAgPT09IGZhbHNlICYmICggb3B0cy5jdXJyU2xpZGUgKyBjb3VudCApID4gb3B0cy5zbGlkZUNvdW50IC0gb3B0cy5jYXJvdXNlbFZpc2libGUgKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgb3B0cy5BUEkuYWR2YW5jZVNsaWRlKCBjb3VudCApO1xyXG4gICAgICAgIG9wdHMuQVBJLnRyaWdnZXIoJ2N5Y2xlLW5leHQnLCBbIG9wdHMgXSkubG9nKCdjeWNsZS1uZXh0Jyk7XHJcbiAgICB9O1xyXG5cclxufSk7XHJcblxyXG5cclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5jYXJvdXNlbCA9IHtcclxuICAgIC8vIHRyYW5zaXRpb24gQVBJIGltcGxcclxuICAgIHByZUluaXQ6IGZ1bmN0aW9uKCBvcHRzICkge1xyXG4gICAgICAgIG9wdHMuaGlkZU5vbkFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIG9wdHMuY29udGFpbmVyLm9uKCdjeWNsZS1kZXN0cm95ZWQnLCAkLnByb3h5KHRoaXMub25EZXN0cm95LCBvcHRzLkFQSSkpO1xyXG4gICAgICAgIC8vIG92ZXJyaWRlIGRlZmF1bHQgQVBJIGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgb3B0cy5BUEkuc3RvcFRyYW5zaXRpb24gPSB0aGlzLnN0b3BUcmFuc2l0aW9uO1xyXG5cclxuICAgICAgICAvLyBpc3N1ZSAjMTBcclxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBvcHRzLnN0YXJ0aW5nU2xpZGU7IGkrKykge1xyXG4gICAgICAgICAgICBvcHRzLmNvbnRhaW5lci5hcHBlbmQoIG9wdHMuc2xpZGVzWzBdICk7XHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHRyYW5zaXRpb24gQVBJIGltcGxcclxuICAgIHBvc3RJbml0OiBmdW5jdGlvbiggb3B0cyApIHtcclxuICAgICAgICB2YXIgaSwgaiwgc2xpZGUsIHBhZ2VyQ3V0b2ZmSW5kZXgsIHdyYXA7XHJcbiAgICAgICAgdmFyIHZlcnQgPSBvcHRzLmNhcm91c2VsVmVydGljYWw7XHJcbiAgICAgICAgaWYgKG9wdHMuY2Fyb3VzZWxWaXNpYmxlICYmIG9wdHMuY2Fyb3VzZWxWaXNpYmxlID4gb3B0cy5zbGlkZUNvdW50KVxyXG4gICAgICAgICAgICBvcHRzLmNhcm91c2VsVmlzaWJsZSA9IG9wdHMuc2xpZGVDb3VudCAtIDE7XHJcbiAgICAgICAgdmFyIHZpc0NvdW50ID0gb3B0cy5jYXJvdXNlbFZpc2libGUgfHwgb3B0cy5zbGlkZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzbGlkZUNTUyA9IHsgZGlzcGxheTogdmVydCA/ICdibG9jaycgOiAnaW5saW5lLWJsb2NrJywgcG9zaXRpb246ICdzdGF0aWMnIH07XHJcblxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHN0eWxlc1xyXG4gICAgICAgIG9wdHMuY29udGFpbmVyLmNzcyh7IHBvc2l0aW9uOiAncmVsYXRpdmUnLCBvdmVyZmxvdzogJ2hpZGRlbicgfSk7XHJcbiAgICAgICAgb3B0cy5zbGlkZXMuY3NzKCBzbGlkZUNTUyApO1xyXG5cclxuICAgICAgICBvcHRzLl9jdXJyU2xpZGUgPSBvcHRzLmN1cnJTbGlkZTtcclxuXHJcbiAgICAgICAgLy8gd3JhcCBzbGlkZXMgaW4gYSBkaXY7IHRoaXMgZGl2IGlzIHdoYXQgaXMgYW5pbWF0ZWRcclxuICAgICAgICB3cmFwID0gJCgnPGRpdiBjbGFzcz1cImN5Y2xlLWNhcm91c2VsLXdyYXBcIj48L2Rpdj4nKVxyXG4gICAgICAgICAgICAucHJlcGVuZFRvKCBvcHRzLmNvbnRhaW5lciApXHJcbiAgICAgICAgICAgIC5jc3MoeyBtYXJnaW46IDAsIHBhZGRpbmc6IDAsIHRvcDogMCwgbGVmdDogMCwgcG9zaXRpb246ICdhYnNvbHV0ZScgfSlcclxuICAgICAgICAgICAgLmFwcGVuZCggb3B0cy5zbGlkZXMgKTtcclxuXHJcbiAgICAgICAgb3B0cy5fY2Fyb3VzZWxXcmFwID0gd3JhcDtcclxuXHJcbiAgICAgICAgaWYgKCAhdmVydCApXHJcbiAgICAgICAgICAgIHdyYXAuY3NzKCd3aGl0ZS1zcGFjZScsICdub3dyYXAnKTtcclxuXHJcbiAgICAgICAgaWYgKCBvcHRzLmFsbG93V3JhcCAhPT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgIC8vIHByZXBlbmQgYW5kIGFwcGVuZCBleHRyYSBzbGlkZXMgc28gd2UgZG9uJ3Qgc2VlIGFueSBlbXB0eSBzcGFjZSB3aGVuIHdlXHJcbiAgICAgICAgICAgIC8vIG5lYXIgdGhlIGVuZCBvZiB0aGUgY2Fyb3VzZWwuICBmb3IgZmx1aWQgY29udGFpbmVycywgYWRkIGV2ZW4gbW9yZSBjbG9uZXNcclxuICAgICAgICAgICAgLy8gc28gdGhlcmUgaXMgcGxlbnR5IHRvIGZpbGwgdGhlIHNjcmVlblxyXG4gICAgICAgICAgICAvLyBAdG9kbzogb3B0aW16aWUgdGhpcyBiYXNlZCBvbiBzbGlkZSBzaXplc1xyXG5cclxuICAgICAgICAgICAgZm9yICggaj0wOyBqIDwgKG9wdHMuY2Fyb3VzZWxWaXNpYmxlID09PSB1bmRlZmluZWQgPyAyIDogMSk7IGorKyApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoIGk9MDsgaSA8IG9wdHMuc2xpZGVDb3VudDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdyYXAuYXBwZW5kKCBvcHRzLnNsaWRlc1tpXS5jbG9uZU5vZGUodHJ1ZSkgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGkgPSBvcHRzLnNsaWRlQ291bnQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHsgLy8gIzE2MCwgIzIwOVxyXG4gICAgICAgICAgICAgICAgICAgIHdyYXAucHJlcGVuZCggb3B0cy5zbGlkZXNbaV0uY2xvbmVOb2RlKHRydWUpICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHdyYXAuZmluZCgnLmN5Y2xlLXNsaWRlLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdjeWNsZS1zbGlkZS1hY3RpdmUnKTtcclxuICAgICAgICAgICAgb3B0cy5zbGlkZXMuZXEob3B0cy5zdGFydGluZ1NsaWRlKS5hZGRDbGFzcygnY3ljbGUtc2xpZGUtYWN0aXZlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG9wdHMucGFnZXIgJiYgb3B0cy5hbGxvd1dyYXAgPT09IGZhbHNlICkge1xyXG4gICAgICAgICAgICAvLyBoaWRlIFwiZXh0cmFcIiBwYWdlcnNcclxuICAgICAgICAgICAgcGFnZXJDdXRvZmZJbmRleCA9IG9wdHMuc2xpZGVDb3VudCAtIHZpc0NvdW50O1xyXG4gICAgICAgICAgICAkKCBvcHRzLnBhZ2VyICkuY2hpbGRyZW4oKS5maWx0ZXIoICc6Z3QoJytwYWdlckN1dG9mZkluZGV4KycpJyApLmhpZGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdHMuX25leHRCb3VuZHJ5ID0gb3B0cy5zbGlkZUNvdW50IC0gb3B0cy5jYXJvdXNlbFZpc2libGU7XHJcblxyXG4gICAgICAgIHRoaXMucHJlcGFyZURpbWVuc2lvbnMoIG9wdHMgKTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJlcGFyZURpbWVuc2lvbnM6IGZ1bmN0aW9uKCBvcHRzICkge1xyXG4gICAgICAgIHZhciBkaW0sIG9mZnNldCwgcGFnZXJDdXRvZmZJbmRleCwgdG1wLCBqO1xyXG4gICAgICAgIHZhciB2ZXJ0ID0gb3B0cy5jYXJvdXNlbFZlcnRpY2FsO1xyXG4gICAgICAgIHZhciB2aXNDb3VudCA9IG9wdHMuY2Fyb3VzZWxWaXNpYmxlIHx8IG9wdHMuc2xpZGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKCBvcHRzLmNhcm91c2VsRmx1aWQgJiYgb3B0cy5jYXJvdXNlbFZpc2libGUgKSB7XHJcbiAgICAgICAgICAgIGlmICggISBvcHRzLl9jYXJvdXNlbFJlc2l6ZVRocm90dGxlICkge1xyXG4gICAgICAgICAgICAvLyBmbHVpZCBjb250YWluZXIgQU5EIGZsdWlkIHNsaWRlczsgc2xpZGVzIG5lZWQgdG8gYmUgcmVzaXplZCB0byBmaXQgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZsdWlkU2xpZGVzKCBvcHRzICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIG9wdHMuY2Fyb3VzZWxWaXNpYmxlICYmIG9wdHMuY2Fyb3VzZWxTbGlkZURpbWVuc2lvbiApIHtcclxuICAgICAgICAgICAgZGltID0gdmlzQ291bnQgKiBvcHRzLmNhcm91c2VsU2xpZGVEaW1lbnNpb247XHJcbiAgICAgICAgICAgIG9wdHMuY29udGFpbmVyWyB2ZXJ0ID8gJ2hlaWdodCcgOiAnd2lkdGgnIF0oIGRpbSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICggb3B0cy5jYXJvdXNlbFZpc2libGUgKSB7XHJcbiAgICAgICAgICAgIGRpbSA9IHZpc0NvdW50ICogJChvcHRzLnNsaWRlc1swXSlbdmVydCA/ICdvdXRlckhlaWdodCcgOiAnb3V0ZXJXaWR0aCddKHRydWUpO1xyXG4gICAgICAgICAgICBvcHRzLmNvbnRhaW5lclsgdmVydCA/ICdoZWlnaHQnIDogJ3dpZHRoJyBdKCBkaW0gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgIC8vIGZsdWlkOyBkb24ndCBzaXplIHRoZSBjb250YWluZXJcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIG9mZnNldCA9ICggb3B0cy5jYXJvdXNlbE9mZnNldCB8fCAwICk7XHJcbiAgICAgICAgaWYgKCBvcHRzLmFsbG93V3JhcCAhPT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgIGlmICggb3B0cy5jYXJvdXNlbFNsaWRlRGltZW5zaW9uICkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0IC09ICggKG9wdHMuc2xpZGVDb3VudCArIG9wdHMuY3VyclNsaWRlKSAqIG9wdHMuY2Fyb3VzZWxTbGlkZURpbWVuc2lvbiApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG9mZnNldCBiYXNlZCBvbiBhY3R1YWwgc2xpZGUgZGltZW5zaW9uc1xyXG4gICAgICAgICAgICAgICAgdG1wID0gb3B0cy5fY2Fyb3VzZWxXcmFwLmNoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGo9MDsgaiA8IChvcHRzLnNsaWRlQ291bnQgKyBvcHRzLmN1cnJTbGlkZSk7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSAkKHRtcFtqXSlbdmVydD8nb3V0ZXJIZWlnaHQnOidvdXRlcldpZHRoJ10odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdHMuX2Nhcm91c2VsV3JhcC5jc3MoIHZlcnQgPyAndG9wJyA6ICdsZWZ0Jywgb2Zmc2V0ICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdWlkU2xpZGVzOiBmdW5jdGlvbiggb3B0cyApIHtcclxuICAgICAgICB2YXIgdGltZW91dDtcclxuICAgICAgICB2YXIgc2xpZGUgPSBvcHRzLnNsaWRlcy5lcSgwKTtcclxuICAgICAgICB2YXIgYWRqdXN0bWVudCA9IHNsaWRlLm91dGVyV2lkdGgoKSAtIHNsaWRlLndpZHRoKCk7XHJcbiAgICAgICAgdmFyIHByZXBhcmVEaW1lbnNpb25zID0gdGhpcy5wcmVwYXJlRGltZW5zaW9ucztcclxuXHJcbiAgICAgICAgLy8gdGhyb3R0bGUgcmVzaXplIGV2ZW50XHJcbiAgICAgICAgJCh3aW5kb3cpLm9uKCAncmVzaXplJywgcmVzaXplVGhyb3R0bGUpO1xyXG5cclxuICAgICAgICBvcHRzLl9jYXJvdXNlbFJlc2l6ZVRocm90dGxlID0gcmVzaXplVGhyb3R0bGU7XHJcbiAgICAgICAgb25SZXNpemUoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzaXplVGhyb3R0bGUoKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGltZW91dCApO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCggb25SZXNpemUsIDIwICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcclxuICAgICAgICAgICAgb3B0cy5fY2Fyb3VzZWxXcmFwLnN0b3AoIGZhbHNlLCB0cnVlICk7XHJcbiAgICAgICAgICAgIHZhciBzbGlkZVdpZHRoID0gb3B0cy5jb250YWluZXIud2lkdGgoKSAvIG9wdHMuY2Fyb3VzZWxWaXNpYmxlO1xyXG4gICAgICAgICAgICBzbGlkZVdpZHRoID0gTWF0aC5jZWlsKCBzbGlkZVdpZHRoIC0gYWRqdXN0bWVudCApO1xyXG4gICAgICAgICAgICBvcHRzLl9jYXJvdXNlbFdyYXAuY2hpbGRyZW4oKS53aWR0aCggc2xpZGVXaWR0aCApO1xyXG4gICAgICAgICAgICBpZiAoIG9wdHMuX3NlbnRpbmVsIClcclxuICAgICAgICAgICAgICAgIG9wdHMuX3NlbnRpbmVsLndpZHRoKCBzbGlkZVdpZHRoICk7XHJcbiAgICAgICAgICAgIHByZXBhcmVEaW1lbnNpb25zKCBvcHRzICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB0cmFuc2l0aW9uIEFQSSBpbXBsXHJcbiAgICB0cmFuc2l0aW9uOiBmdW5jdGlvbiggb3B0cywgY3VyciwgbmV4dCwgZndkLCBjYWxsYmFjayApIHtcclxuICAgICAgICB2YXIgbW92ZUJ5LCBwcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBob3BzID0gb3B0cy5uZXh0U2xpZGUgLSBvcHRzLmN1cnJTbGlkZTtcclxuICAgICAgICB2YXIgdmVydCA9IG9wdHMuY2Fyb3VzZWxWZXJ0aWNhbDtcclxuICAgICAgICB2YXIgc3BlZWQgPSBvcHRzLnNwZWVkO1xyXG5cclxuICAgICAgICAvLyBoYW5kbGUgYWxsIHRoZSBlZGdlIGNhc2VzIGZvciB3cmFwcGluZyAmIG5vbi13cmFwcGluZ1xyXG4gICAgICAgIGlmICggb3B0cy5hbGxvd1dyYXAgPT09IGZhbHNlICkge1xyXG4gICAgICAgICAgICBmd2QgPSBob3BzID4gMDtcclxuICAgICAgICAgICAgdmFyIGN1cnJTbGlkZSA9IG9wdHMuX2N1cnJTbGlkZTtcclxuICAgICAgICAgICAgdmFyIG1heEN1cnIgPSBvcHRzLnNsaWRlQ291bnQgLSBvcHRzLmNhcm91c2VsVmlzaWJsZTtcclxuICAgICAgICAgICAgaWYgKCBob3BzID4gMCAmJiBvcHRzLm5leHRTbGlkZSA+IG1heEN1cnIgJiYgY3VyclNsaWRlID09IG1heEN1cnIgKSB7XHJcbiAgICAgICAgICAgICAgICBob3BzID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICggaG9wcyA+IDAgJiYgb3B0cy5uZXh0U2xpZGUgPiBtYXhDdXJyICkge1xyXG4gICAgICAgICAgICAgICAgaG9wcyA9IG9wdHMubmV4dFNsaWRlIC0gY3VyclNsaWRlIC0gKG9wdHMubmV4dFNsaWRlIC0gbWF4Q3Vycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIGhvcHMgPCAwICYmIG9wdHMuY3VyclNsaWRlID4gbWF4Q3VyciAmJiBvcHRzLm5leHRTbGlkZSA+IG1heEN1cnIgKSB7XHJcbiAgICAgICAgICAgICAgICBob3BzID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICggaG9wcyA8IDAgJiYgb3B0cy5jdXJyU2xpZGUgPiBtYXhDdXJyICkge1xyXG4gICAgICAgICAgICAgICAgaG9wcyArPSBvcHRzLmN1cnJTbGlkZSAtIG1heEN1cnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBcclxuICAgICAgICAgICAgICAgIGN1cnJTbGlkZSA9IG9wdHMuY3VyclNsaWRlO1xyXG5cclxuICAgICAgICAgICAgbW92ZUJ5ID0gdGhpcy5nZXRTY3JvbGwoIG9wdHMsIHZlcnQsIGN1cnJTbGlkZSwgaG9wcyApO1xyXG4gICAgICAgICAgICBvcHRzLkFQSS5vcHRzKCkuX2N1cnJTbGlkZSA9IG9wdHMubmV4dFNsaWRlID4gbWF4Q3VyciA/IG1heEN1cnIgOiBvcHRzLm5leHRTbGlkZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICggZndkICYmIG9wdHMubmV4dFNsaWRlID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgLy8gbW92aW5nIGZyb20gbGFzdCBzbGlkZSB0byBmaXJzdFxyXG4gICAgICAgICAgICAgICAgbW92ZUJ5ID0gdGhpcy5nZXREaW0oIG9wdHMsIG9wdHMuY3VyclNsaWRlLCB2ZXJ0ICk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHRoaXMuZ2VuQ2FsbGJhY2soIG9wdHMsIGZ3ZCwgdmVydCwgY2FsbGJhY2sgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICggIWZ3ZCAmJiBvcHRzLm5leHRTbGlkZSA9PSBvcHRzLnNsaWRlQ291bnQgLSAxICkge1xyXG4gICAgICAgICAgICAgICAgLy8gbW92aW5nIGZyb20gZmlyc3Qgc2xpZGUgdG8gbGFzdFxyXG4gICAgICAgICAgICAgICAgbW92ZUJ5ID0gdGhpcy5nZXREaW0oIG9wdHMsIG9wdHMuY3VyclNsaWRlLCB2ZXJ0ICk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHRoaXMuZ2VuQ2FsbGJhY2soIG9wdHMsIGZ3ZCwgdmVydCwgY2FsbGJhY2sgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vdmVCeSA9IHRoaXMuZ2V0U2Nyb2xsKCBvcHRzLCB2ZXJ0LCBvcHRzLmN1cnJTbGlkZSwgaG9wcyApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9wc1sgdmVydCA/ICd0b3AnIDogJ2xlZnQnIF0gPSBmd2QgPyAoIFwiLT1cIiArIG1vdmVCeSApIDogKCBcIis9XCIgKyBtb3ZlQnkgKTtcclxuXHJcbiAgICAgICAgLy8gdGhyb3R0bGVTcGVlZCBtZWFucyB0byBzY3JvbGwgc2xpZGVzIGF0IGEgY29uc3RhbnQgcmF0ZSwgcmF0aGVyIHRoYW5cclxuICAgICAgICAvLyBhIGNvbnN0YW50IHNwZWVkXHJcbiAgICAgICAgaWYgKCBvcHRzLnRocm90dGxlU3BlZWQgKVxyXG4gICAgICAgICAgICBzcGVlZCA9IChtb3ZlQnkgLyAkKG9wdHMuc2xpZGVzWzBdKVt2ZXJ0ID8gJ2hlaWdodCcgOiAnd2lkdGgnXSgpICkgKiBvcHRzLnNwZWVkO1xyXG5cclxuICAgICAgICBvcHRzLl9jYXJvdXNlbFdyYXAuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBvcHRzLmVhc2luZywgY2FsbGJhY2sgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RGltOiBmdW5jdGlvbiggb3B0cywgaW5kZXgsIHZlcnQgKSB7XHJcbiAgICAgICAgdmFyIHNsaWRlID0gJCggb3B0cy5zbGlkZXNbaW5kZXhdICk7XHJcbiAgICAgICAgcmV0dXJuIHNsaWRlWyB2ZXJ0ID8gJ291dGVySGVpZ2h0JyA6ICdvdXRlcldpZHRoJ10odHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFNjcm9sbDogZnVuY3Rpb24oIG9wdHMsIHZlcnQsIGN1cnJTbGlkZSwgaG9wcyApIHtcclxuICAgICAgICB2YXIgaSwgbW92ZUJ5ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKGhvcHMgPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAoaT1jdXJyU2xpZGU7IGkgPCBjdXJyU2xpZGUraG9wczsgaSsrKVxyXG4gICAgICAgICAgICAgICAgbW92ZUJ5ICs9IHRoaXMuZ2V0RGltKCBvcHRzLCBpLCB2ZXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaT1jdXJyU2xpZGU7IGkgPiBjdXJyU2xpZGUraG9wczsgaS0tKVxyXG4gICAgICAgICAgICAgICAgbW92ZUJ5ICs9IHRoaXMuZ2V0RGltKCBvcHRzLCBpLCB2ZXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vdmVCeTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2VuQ2FsbGJhY2s6IGZ1bmN0aW9uKCBvcHRzLCBmd2QsIHZlcnQsIGNhbGxiYWNrICkge1xyXG4gICAgICAgIC8vIHJldHVybnMgY2FsbGJhY2sgZm4gdGhhdCByZXNldHMgdGhlIGxlZnQvdG9wIHdyYXAgcG9zaXRpb24gdG8gdGhlIFwicmVhbFwiIHNsaWRlc1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHBvcyA9ICQob3B0cy5zbGlkZXNbb3B0cy5uZXh0U2xpZGVdKS5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMCAtIHBvc1t2ZXJ0Pyd0b3AnOidsZWZ0J10gKyAob3B0cy5jYXJvdXNlbE9mZnNldCB8fCAwKTtcclxuICAgICAgICAgICAgb3B0cy5fY2Fyb3VzZWxXcmFwLmNzcyggb3B0cy5jYXJvdXNlbFZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsIG9mZnNldCApO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGNvcmUgQVBJIG92ZXJyaWRlXHJcbiAgICBzdG9wVHJhbnNpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHMoKTtcclxuICAgICAgICBvcHRzLnNsaWRlcy5zdG9wKCBmYWxzZSwgdHJ1ZSApO1xyXG4gICAgICAgIG9wdHMuX2Nhcm91c2VsV3JhcC5zdG9wKCBmYWxzZSwgdHJ1ZSApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjb3JlIEFQSSBzdXBwbGVtZW50XHJcbiAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uKCBlICkge1xyXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzKCk7XHJcbiAgICAgICAgaWYgKCBvcHRzLl9jYXJvdXNlbFJlc2l6ZVRocm90dGxlIClcclxuICAgICAgICAgICAgJCggd2luZG93ICkub2ZmKCAncmVzaXplJywgb3B0cy5fY2Fyb3VzZWxSZXNpemVUaHJvdHRsZSApO1xyXG4gICAgICAgIG9wdHMuc2xpZGVzLnByZXBlbmRUbyggb3B0cy5jb250YWluZXIgKTtcclxuICAgICAgICBvcHRzLl9jYXJvdXNlbFdyYXAucmVtb3ZlKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG59KShqUXVlcnkpO1xyXG4iLCIvKiEgc2h1ZmZsZSB0cmFuc2l0aW9uIHBsdWdpbiBmb3IgQ3ljbGUyOyAgdmVyc2lvbjogMjAxNDAxMjggKi9cclxuKGZ1bmN0aW9uKCQpIHtcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLnNodWZmbGUgPSB7XHJcblxyXG4gICAgdHJhbnNpdGlvbjogZnVuY3Rpb24oIG9wdHMsIGN1cnJFbCwgbmV4dEVsLCBmd2QsIGNhbGxiYWNrICkge1xyXG4gICAgICAgICQoIG5leHRFbCApLmNzcyh7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IG9wdHMuY29udGFpbmVyLmNzcyggJ292ZXJmbG93JywgJ3Zpc2libGUnICkud2lkdGgoKTtcclxuICAgICAgICB2YXIgc3BlZWQgPSBvcHRzLnNwZWVkIC8gMjsgLy8gc2h1ZmZsZSBoYXMgMiB0cmFuc2l0aW9uc1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gZndkID8gY3VyckVsIDogbmV4dEVsO1xyXG5cclxuICAgICAgICBvcHRzID0gb3B0cy5BUEkuZ2V0U2xpZGVPcHRzKCBmd2QgPyBvcHRzLmN1cnJTbGlkZSA6IG9wdHMubmV4dFNsaWRlICk7XHJcbiAgICAgICAgdmFyIHByb3BzMSA9IHsgbGVmdDotd2lkdGgsIHRvcDoxNSB9O1xyXG4gICAgICAgIHZhciBwcm9wczIgPSAgb3B0cy5zbGlkZUNzcyB8fCB7IGxlZnQ6MCwgdG9wOjAgfTtcclxuXHJcbiAgICAgICAgaWYgKCBvcHRzLnNodWZmbGVMZWZ0ICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgIHByb3BzMS5sZWZ0ID0gcHJvcHMxLmxlZnQgKyBwYXJzZUludChvcHRzLnNodWZmbGVMZWZ0LCAxMCkgfHwgMDtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2UgaWYgKCBvcHRzLnNodWZmbGVSaWdodCAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICBwcm9wczEubGVmdCA9IHdpZHRoICsgcGFyc2VJbnQob3B0cy5zaHVmZmxlUmlnaHQsIDEwKSB8fCAwO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgaWYgKCBvcHRzLnNodWZmbGVUb3AgKSB7XHJcbiAgICAgICAgICAgIHByb3BzMS50b3AgPSBvcHRzLnNodWZmbGVUb3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0cmFuc2l0aW9uIHNsaWRlIGluIDMgc3RlcHM6IG1vdmUsIHJlLXppbmRleCwgbW92ZVxyXG4gICAgICAgICQoIGVsZW1lbnQgKVxyXG4gICAgICAgICAgICAuYW5pbWF0ZSggcHJvcHMxLCBzcGVlZCwgb3B0cy5lYXNlSW4gfHwgb3B0cy5lYXNpbmcgKVxyXG4gICAgICAgICAgICAucXVldWUoICdmeCcsICQucHJveHkocmVJbmRleCwgdGhpcykpXHJcbiAgICAgICAgICAgIC5hbmltYXRlKCBwcm9wczIsIHNwZWVkLCBvcHRzLmVhc2VPdXQgfHwgb3B0cy5lYXNpbmcsIGNhbGxiYWNrICk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlSW5kZXgobmV4dEZuKSB7XHJcbiAgICAgICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sob3B0cywgY3VyckVsLCBuZXh0RWwsIGZ3ZCk7XHJcbiAgICAgICAgICAgIG5leHRGbigpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3RhY2s6IGZ1bmN0aW9uKCBvcHRzLCBjdXJyRWwsIG5leHRFbCwgZndkICkge1xyXG4gICAgICAgIHZhciBpLCB6O1xyXG5cclxuICAgICAgICBpZiAoZndkKSB7XHJcbiAgICAgICAgICAgIG9wdHMuQVBJLnN0YWNrU2xpZGVzKCBuZXh0RWwsIGN1cnJFbCwgZndkICk7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIGN1cnIgc2xpZGUgdG8gYm90dG9tIG9mIHRoZSBzdGFja1xyXG4gICAgICAgICAgICAkKGN1cnJFbCkuY3NzKCAnekluZGV4JywgMSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeiA9IDE7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IG9wdHMubmV4dFNsaWRlIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICQob3B0cy5zbGlkZXNbaV0pLmNzcygnekluZGV4JywgeisrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSBvcHRzLnNsaWRlQ291bnQgLSAxOyBpID4gb3B0cy5uZXh0U2xpZGU7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgJChvcHRzLnNsaWRlc1tpXSkuY3NzKCd6SW5kZXgnLCB6KyspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICQobmV4dEVsKS5jc3MoICd6SW5kZXgnLCBvcHRzLm1heFogKTtcclxuICAgICAgICAgICAgJChjdXJyRWwpLmNzcyggJ3pJbmRleCcsIG9wdHMubWF4WiAtIDEgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG59KShqUXVlcnkpO1xyXG4iLCIvKiEgdGlsZSB0cmFuc2l0aW9uIHBsdWdpbiBmb3IgQ3ljbGUyOyAgdmVyc2lvbjogMjAxNDAxMjggKi9cclxuKGZ1bmN0aW9uICgkKSB7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy50aWxlU2xpZGUgPVxyXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLnRpbGVCbGluZCA9IHtcclxuXHJcbiAgICBiZWZvcmU6IGZ1bmN0aW9uKCBvcHRzLCBjdXJyLCBuZXh0LCBmd2QgKSB7XHJcbiAgICAgICAgb3B0cy5BUEkuc3RhY2tTbGlkZXMoIGN1cnIsIG5leHQsIGZ3ZCApO1xyXG4gICAgICAgICQoY3VycikuY3NzKHtcclxuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb3B0cy5jb250YWluZXIuY3NzKCdvdmVyZmxvdycsICdoaWRkZW4nKTtcclxuICAgICAgICAvLyBzZXQgZGVmYXVsdHNcclxuICAgICAgICBvcHRzLnRpbGVEZWxheSA9IG9wdHMudGlsZURlbGF5IHx8IG9wdHMuZnggPT0gJ3RpbGVTbGlkZScgPyAxMDAgOiAxMjU7XHJcbiAgICAgICAgb3B0cy50aWxlQ291bnQgPSBvcHRzLnRpbGVDb3VudCB8fCA3O1xyXG4gICAgICAgIG9wdHMudGlsZVZlcnRpY2FsID0gb3B0cy50aWxlVmVydGljYWwgIT09IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIW9wdHMuY29udGFpbmVyLmRhdGEoJ2N5Y2xlVGlsZUluaXRpYWxpemVkJykpIHtcclxuICAgICAgICAgICAgb3B0cy5jb250YWluZXIub24oJ2N5Y2xlLWRlc3Ryb3llZCcsICQucHJveHkodGhpcy5vbkRlc3Ryb3ksIG9wdHMuQVBJKSk7XHJcbiAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLmRhdGEoJ2N5Y2xlVGlsZUluaXRpYWxpemVkJywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2l0aW9uOiBmdW5jdGlvbiggb3B0cywgY3VyciwgbmV4dCwgZndkLCBjYWxsYmFjayApIHtcclxuICAgICAgICBvcHRzLnNsaWRlcy5ub3QoY3Vycikubm90KG5leHQpLmNzcygndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xyXG5cclxuICAgICAgICB2YXIgdGlsZXMgPSAkKCk7XHJcbiAgICAgICAgdmFyICRjdXJyID0gJChjdXJyKSwgJG5leHQgPSAkKG5leHQpO1xyXG4gICAgICAgIHZhciB0aWxlLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIGxhc3RUaWxlV2lkdGgsIGxhc3RUaWxlSGVpZ2h0LFxyXG4gICAgICAgICAgICBudW0gPSBvcHRzLnRpbGVDb3VudCxcclxuICAgICAgICAgICAgdmVydCA9IG9wdHMudGlsZVZlcnRpY2FsLFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBvcHRzLmNvbnRhaW5lci5oZWlnaHQoKSxcclxuICAgICAgICAgICAgd2lkdGggPSBvcHRzLmNvbnRhaW5lci53aWR0aCgpO1xyXG5cclxuICAgICAgICBpZiAoIHZlcnQgKSB7XHJcbiAgICAgICAgICAgIHRpbGVXaWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyBudW0pO1xyXG4gICAgICAgICAgICBsYXN0VGlsZVdpZHRoID0gd2lkdGggLSAodGlsZVdpZHRoICogKG51bSAtIDEpKTtcclxuICAgICAgICAgICAgdGlsZUhlaWdodCA9IGxhc3RUaWxlSGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGlsZVdpZHRoID0gbGFzdFRpbGVXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB0aWxlSGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgLyBudW0pO1xyXG4gICAgICAgICAgICBsYXN0VGlsZUhlaWdodCA9IGhlaWdodCAtICh0aWxlSGVpZ2h0ICogKG51bSAtIDEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG9wdHMuc3BlZWQgPSBvcHRzLnNwZWVkIC8gMjtcclxuICAgICAgICBvcHRzLmNvbnRhaW5lci5maW5kKCcuY3ljbGUtdGlsZXMtY29udGFpbmVyJykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIHZhciBhbmltQ1NTO1xyXG4gICAgICAgIHZhciB0aWxlQ1NTID0geyBsZWZ0OiAwLCB0b3A6IDAsIG92ZXJmbG93OiAnaGlkZGVuJywgcG9zaXRpb246ICdhYnNvbHV0ZScsIG1hcmdpbjogMCwgcGFkZGluZzogMCB9O1xyXG4gICAgICAgIGlmICggdmVydCApIHtcclxuICAgICAgICAgICAgYW5pbUNTUyA9IG9wdHMuZnggPT0gJ3RpbGVTbGlkZScgPyB7IHRvcDogaGVpZ2h0IH0gOiB7IHdpZHRoOiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhbmltQ1NTID0gb3B0cy5meCA9PSAndGlsZVNsaWRlJyA/IHsgbGVmdDogd2lkdGggfSA6IHsgaGVpZ2h0OiAwIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGlsZXNDb250YWluZXIgPSAkKCc8ZGl2IGNsYXNzPVwiY3ljbGUtdGlsZXMtY29udGFpbmVyXCI+PC9kaXY+Jyk7XHJcbiAgICAgICAgdGlsZXNDb250YWluZXIuY3NzKHtcclxuICAgICAgICAgICAgekluZGV4OiAkY3Vyci5jc3MoJ3otaW5kZXgnKSxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcclxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsIFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ2x0cicgLy8gIzI1MFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRpbGVzQ29udGFpbmVyLmluc2VydEJlZm9yZSggbmV4dCApO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRpbGUgPSAkKCc8ZGl2PjwvZGl2PicpXHJcbiAgICAgICAgICAgIC5jc3MoIHRpbGVDU1MgKVxyXG4gICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAgKChudW0gLSAxID09PSBpKSA/IGxhc3RUaWxlV2lkdGggIDogdGlsZVdpZHRoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogKChudW0gLSAxID09PSBpKSA/IGxhc3RUaWxlSGVpZ2h0IDogdGlsZUhlaWdodCksXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiB2ZXJ0ID8gKChpICogdGlsZVdpZHRoKSkgOiAwLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAgdmVydCA/IDAgOiAoaSAqIHRpbGVIZWlnaHQpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJGN1cnIuY2xvbmUoKS5jc3Moe1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6ICRjdXJyLndpZHRoKCksXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDAsIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiB2ZXJ0ID8gLShpICogdGlsZVdpZHRoKSA6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHZlcnQgPyAwIDogLShpICogdGlsZUhlaWdodClcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aWxlcyA9IHRpbGVzLmFkZCh0aWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRpbGVzQ29udGFpbmVyLmFwcGVuZCh0aWxlcyk7XHJcbiAgICAgICAgJGN1cnIuY3NzKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XHJcbiAgICAgICAgJG5leHQuY3NzKHtcclxuICAgICAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYW5pbWF0ZVRpbGUoZndkID8gMCA6IG51bSAtIDEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIG9wdHMuX3RpbGVBbmlDYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAkbmV4dC5jc3Moe1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJGN1cnIuY3NzKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIHRpbGVzQ29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFuaW1hdGVUaWxlKGkpIHtcclxuICAgICAgICAgICAgdGlsZXMuZXEoaSkuYW5pbWF0ZSggYW5pbUNTUywge1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdHMuc3BlZWQsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmc6IG9wdHMuZWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZndkID8gKG51bSAtIDEgPT09IGkpIDogKDAgPT09IGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuX3RpbGVBbmlDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmd2QgPyAobnVtIC0gMSAhPT0gaSkgOiAoMCAhPT0gaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlVGlsZShmd2QgPyAoaSArIDEpIDogKGkgLSAxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIG9wdHMudGlsZURlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHR4IEFQSSBpbXBsXHJcbiAgICBzdG9wVHJhbnNpdGlvbjogZnVuY3Rpb24oIG9wdHMgKSB7XHJcbiAgICAgICAgb3B0cy5jb250YWluZXIuZmluZCgnKicpLnN0b3AoIHRydWUsIHRydWUgKTtcclxuICAgICAgICBpZiAob3B0cy5fdGlsZUFuaUNhbGxiYWNrKVxyXG4gICAgICAgICAgICBvcHRzLl90aWxlQW5pQ2FsbGJhY2soKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gY29yZSBBUEkgc3VwcGxlbWVudFxyXG4gICAgb25EZXN0cm95OiBmdW5jdGlvbiggZSApIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cygpO1xyXG4gICAgICAgIG9wdHMuY29udGFpbmVyLmZpbmQoJy5jeWNsZS10aWxlcy1jb250YWluZXInKS5yZW1vdmUoKTtcclxuICAgIH1cclxufTtcclxuXHJcbn0pKGpRdWVyeSk7XHJcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
